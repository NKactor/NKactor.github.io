[{"title":"centOS+Nginx+uWsgi部署Django项目","date":"2018-12-15T02:54:35.000Z","path":"2018/12/15/centOS与Nginx与uWsgi部署Django项目/","text":"centOS + Nginx + uWsgi部署Django项目 安装MariaDB&emsp;自己也可以安装mysql，MariaDB是mysql的一个分支，它的安装比较方便，并且它 的使用命令和mysql的相同 &emsp;&emsp;1. 安装命令 yum -y install mariadb mariadb-server &emsp;&emsp;2. 安装完成MariaDB，首先启动MariaDB systemctl start mariadb &emsp;&emsp;3. 设置开机启动 systemctl enable mariadb 设置密码&emsp;&emsp;命令: mysql_secure_installation Enter current password for root:&lt;–初次运行直接回车 设置密码 Set root password? [Y/n] &lt;– 是否设置root用户密码，输入y并回车或直接回车 New password: &lt;– 设置root用户的密码 Re-enter new password: &lt;– 再输入一次你设置的密码 其他配置 Remove anonymous users? [Y/n] &lt;– 是否删除匿名用户，回车 Disallow root login remotely? [Y/n] &lt;–是否禁止root远程登录,回车, Remove test database and access to it? [Y/n] &lt;– 是否删除test数据库，回车 Reload privilege tables now? [Y/n] &lt;– 是否重新加载权限表，回车 初始化MariaDB完成，接下来测试登录 mysql -u root -p 开启远程连接&emsp;&emsp;在mysql数据库中的user表中可以看到默认是只能本地连接的，所有可以添加一个新的用户，该用户可以远程访问 1. 创建用户# 先使用数据库 use mysql; # 针对ip create user &apos;root&apos;@&apos;192.168.10.10&apos; identified by &apos;password&apos;; #全部 create user &apos;root&apos;@&apos;%&apos; identified by &apos;password&apos;; 2. 授权# 给用户最大权限 grant all privileges on *.* to &apos;root&apos;@&apos;%&apos; identified by &apos;password&apos;; # 给部分权限(test 数据库) grant all privileges on test.* to &apos;root&apos;@&apos;%&apos; identified by &apos;password&apos; with grant option; # 刷新权限表 flush privileges; # 查看 show grants for &apos;root&apos;@&apos;localhost&apos;; 接下来就可以在远程的数据库可视化工具中直接访问该服务器中的mysql了。 # 访问数据库 mysql -u root -p 安装python3.6&emsp;&emsp;在centos中，系统默认只提供python2.7的版本，但是项目我们使用的python3.6的版本。所有我们自己安装python3 安装Python3的方法&emsp;&emsp;首先安装依赖包 &emsp;&emsp;安装Python3.6所需要的依赖包： yum -y groupinstall &quot;Development tools&quot; yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel &emsp;&emsp;安装Python3.7还需额外安装依赖包： yum install libffi-devel -y &emsp;&emsp;然后根据自己需求下载不同版本的Python3，这里下载的是Python3.6.2 wget https://www.python.org/ftp/python/3.6.2/Python-3.6.2.tar.xz 然后解压压缩包，进入该目录，安装Python3 tar -xvJf Python-3.6.2.tar.xz cd Python-3.6.2 指定安装路径 ./configure --prefix=/usr/local/python3 make &amp;&amp; make install &emsp;&emsp;最后创建软链接 ln -s /usr/local/python3/bin/python3 /usr/bin/python3 ln -s /usr/local/python3/bin/pip3 /usr/bin/pip3 安装环境1. 安装virtualenvyum install python-virtualenv 2. 创建虚拟环境virtualenv --no-site-packages env 如果你的服务器上有过个python环境这里需要根据自己的项目需求指定用哪个python版本创建虚拟环境（如下） virtualenv --no-site-packages -p /usr/local/python3/bin/python3 进入刚创建的虚拟环境 cd env # 激活虚拟环境 source bin/activate 3. 安装环境需要的包pip3 install -r re_install.txt 我们可以在存放项目代码的文件夹中创建这个re_install.txt文件，把运行项目需要安装包的名称以及对应的版本写在里面。（如下） 进入存放项目代码的文夹中创建re_install.txt文件 cd /home/src/ mkdir re_install.txt 打开文件写入对应的内容 vim re_install.txt 在文件中写入本次项目所需的包 django==1.11 pymysql pillow 部署&emsp;&emsp;该部署采用的是cenots7系统来部署 &emsp;&emsp;Django的项目中，在工程目录下settings.py文件中有一个DEBUG=True参数，如果DEBUG=False则会出现js,css，img无法加载的情况出现。 &emsp;&emsp;原因如下：&emsp;Django框架仅在开发模式下提供静态文件服务。当我开启DEBUG模式时，Django内置的服务器是提供静态文件的服务的，所以css等文件访问都没有问题，但是关闭DEBUG模式后，Django便不提供静态文件服务了。想一想这是符合Django的哲学的：这部分事情标准服务器都很擅长，就让服务器去做吧！ 1. 测试环境中部署方式urls.py中的修改&emsp;&emsp;在测试环境中一般都直接使用python manage.py runserver的方式去运行项目。其中就涉及到DEBUG=False的修改，静态目录的修改等，具体修改如下： a. 修改settings.py配置文件中的DEBUG=False模式，修改ALLOEWD_HOST=[&apos;*&apos;] b. 修改工程目录下的urls.py from django.views.static import serve urlpatterns = [ url(r&apos;^admin/&apos;, admin.site.urls), url(r&apos;^axf/&apos;, include(&apos;axf.urls&apos;, namespace=&apos;axf&apos;)), # 增加以下的url路由 url(r&apos;^static/(?P&lt;path&gt;.*)$&apos;, serve, {&quot;document_root&quot;: settings.STATICFILES_DIRS[0]}), url(r&apos;^media/(?P&lt;path&gt;.*)$&apos;, serve, {&quot;document_root&quot;: settings.MEDIA_ROOT}), url(r&apos;^$&apos;, views.home) ] 中间件的修改&emsp;&emsp;如果中间件是过滤哪些地址不需要登录验证的话，可以设置如下的static和media过滤地址的参数： # 验证用户的登录状态 paths = [&apos;/user/login/&apos;, &apos;/user/register/&apos;,&apos;/static/[0-9a-zA-Z/\\.]&apos;, &apos;/media/[0-9a-zA-Z/\\.]&apos;] for path in paths: if re.match(path, request.path): return None 2. 正式环境中部署方式&emsp;&emsp;正式环境中部署为 Nginx + uwsgi 来部署django项目 2.1 安装nginxa. 添加nginx存储库yum install epel-release b. 安装nginxyum install nginx c. 运行nginx&emsp;&emsp;Nginx不会自行启动。要运行Nginx systemctl start nginx &emsp;&emsp;nginx的运行命令： systemctl status nginx 查看nginx的状态 systemctl start/stop/enable/disable nginx 启动/关闭/设置开机启动/禁止开机启动 d. 系统启动时启用Nginxsystemctl enable nginx e. 如果您正在运行防火墙，请运行以下命令以允许HTTP和HTTPS通信：sudo firewall-cmd --permanent --zone=public --add-service=http sudo firewall-cmd --permanent --zone=public --add-service=https sudo firewall-cmd --reload &emsp;&emsp;运行结果如下: 3.配置uwsgi3.1 安装uwsgi&emsp;&emsp;在虚拟环境中安装uwsgi，假设虚拟环境安装在/home/env/freshenv中,这里强行指定使用虚拟环境中的pip安装，相当于在激活环境状态下安装 方式一： /home/env/freshenv/bin/python3/pip3 install uwsgi 方式二： 进入环境 cd /home/env/freshenv/bin/ 激活环境 source activate 安装相应的包 pip install uwsgi 4. 配置项目代码，配置项目nginx，配置uwsgi.ini等&emsp;&emsp;本案例的配置文件，都习惯将每一个项目的配置文件，日志文件，虚拟环境放在一起，这样开发方便，运维也方便维护 &emsp;&emsp;项目的目录结构如下： &emsp;&emsp;其中： conf是配置文件，用于存放项目的nginx.conf文件，uwsgi.ini文件 logs是日志文件，用于存放nginx的启动成功和失败文件，以及uwsgi的运行日志文件 env是用于存放虚拟环境 src是项目文件，该目录下上传的是目录代码 4.1 配置nginx.conf文件&emsp;&emsp;首先：编写自己项目的nginx.conf文件如下： &emsp;&emsp;每一个项目对应有一个自己定义的nginx的配置文件，比如天天生鲜项目，我定义为TTSX.conf文件 server { # 指定启动端口 listen 80; # 指定服务器ip也就是待会可以通过这个ip访问我们的网站，有域名的就换成自己的域名即可 server_name 192.168.156.1; # 指定成功启动的日志文件存放位置 access_log /home/logs/access.log; # 指定启动失败的日志存放位置 error_log /home/logs/error.log; # 指定静态文件路径 location /static/ { alias /home/src/fresh_shop/static/; expires 30d; } # 指定媒体文件的存放路径 location /media/ { alias /home/src/fresh_shop/media/; } # 指定Nginx服务器与uwsgi通信的ip地址和端口 location / { # 改参数是固定写法 include uwsgi_params; uwsgi_pass 127.0.0.1:8080; } } &emsp;&emsp;其次：修改总的nginx的配置文件，让总的nginx文件包含我们自定义的项目的TTSX.conf文件 &emsp;&emsp;如果Nginx是默认安装路径的话，总的nginx配置文件在：/etc/nginx/nginx.conf中 &emsp;&emsp;以上步骤操作完成以后，需要重启nginx： systemctl restart nginx &emsp;&emsp;如果自定义的TTSX.conf文件没有错误的话，查看nginx的运行状态会有如下的结果： 4.2 配置uwsgi文件&emsp;&emsp;在conf文件夹下除了包含自定义的TTSX.conf文件，还要自定义定义uwsgi.ini文件 [uwsgi] # 下面这两个参数可有可无，没有时就强行指定项目地址即可 projectname = TTSX base = /home/src # 守护进程 master = true # 进程个数，根据需求自行修改 processes = 4 # 指定启动项目使用的虚拟环境 pythonhome = /home/env/freshen # 指定项目存放地址 # chdir = %(base)/%(projectname) chdir = /home/src/fresh_shop # 指定python版本 pythonpath = /usr/local/python3/bin/python3 # 指定uwsgi文件 # module = %(projectname).wsgi module = fresh_shop.wsgi # 指定uwsgi和nginx通信ip:端口(这里必须和上面我们自定义的Nginx配置文件中的一致) socket = 127.0.0.1:8080 # 日志文件地址 logto = /home/logs/uwsgi.log &emsp;&emsp;运行项目: /home/env/freshenv/bin/python3/uwsgi --ini uwsgi.ini","tags":[{"name":"Django","slug":"Django","permalink":"http://yoursite.com/tags/Django/"}]},{"title":"rest_framework总结","date":"2018-12-10T14:47:41.000Z","path":"2018/12/10/rest-framework总结/","text":"django-rest-framework,是一套基于Django 的 REST 框架，是一个强大灵活的构建 Web API 的工具包。 使用django-rest-framework实现前后分离。 rest总结目录 安装与配置 模型定义 路由 视图 序列化 条件过滤 增删改查方法自定义 to_representation方法 get_queryset方法 get_object方法 1. 安装与配置&emsp;&emsp;安装djangorestframework pip install djangorestframework==3.4.6 &emsp;&emsp;安装过滤 pip install django-filter &emsp;&emsp;配置settings.py文件 &emsp;&emsp;在工程目录中的settings.py文件的INSTALLED_APPS中需要添加rest_framework 12345INSTALLED_APPS = [ ... 'rest_framework',] 2. 模型定义&emsp;&emsp;定义文章模型类和文章分类的模型类，并指定分类和文章之间的一对多的关联关系12345678910111213141516171819from django.db import modelsclass Atype(models.Model): t_name = models.CharField(max_length=10) class Meta: db_table = 'a_type'class Article(models.Model): title = models.CharField(max_length=10) desc = models.CharField(max_length=100) content = models.TextField() is_delete = models.BooleanField(default=0) create_time = models.DateTimeField(auto_now_add=True) atype = models.ForeignKey(Atype, null=True) class Meta: db_table = 'article' 3. 路由&emsp;&emsp;定义路由需要注意： 使用router.register注册的url为资源，而且资源只能为名词不能为动词。 定义的资源不要加&apos;/&apos;斜杠，在访问地址的时候，URL中会默认的添加反斜杠&apos;/&apos; 12345678910111213141516171819from django.conf.urls import urlfrom rest_framework.routers import SimpleRouter# 导入应用article中的views.py文件from article import views# 生成路由对象router = SimpleRouter()# 路由管理资源artrouter.register('art', views.ArticleView)urlpatterns = [ url(r'list/', views.list_art),]# router.urls生成资源对应的路由地址# 例如地址: /art/ 、 /art/id/urlpatterns += router.urls 4. 视图&emsp;&emsp;定义基于类的视图ArticleView，可以通过继承父类来实现创建/检索/更新/删除等操作，而开发者只需要轻松地构造可重复使用的行为即可。而这些常见的创建/检索/更新/删除等操作是在REST框架的mixin类中实现的。 &emsp;&emsp;如下定义基于类的视图ArticleView，视图中实现序列化类ArticleSerializer和过滤类ArticleFiler:12345678910111213141516171819from rest_framework import mixins, viewsetsfrom article.article_filter import ArticleFilerfrom article.article_serializer import ArticleSerializerfrom article.models import Articleclass ArticleView(viewsets.GenericViewSet, mixins.ListModelMixin, mixins.DestroyModelMixin, mixins.CreateModelMixin, mixins.UpdateModelMixin, mixins.RetrieveModelMixin): # 查询返回的数据 queryset = Article.objects.filter(is_delete=0) # 序列化返回的文章数据 serializer_class = ArticleSerializer # 过滤 filter_class = ArticleFiler &emsp;&emsp;分析: queryset: 指明在查询数据时使用的查询集。 serializer_class: 指明该视图在进行序列化或反序列化时使用的序列化器。 filter_class: 指明过滤URL中传递参数的过滤器。 5. 序列化&emsp;&emsp;定义序列化模型的ArticleSerializer类，并继承于serializers.ModelSerializer。其中可以自定义序列化字段的最大长度max_length和最小长度min_length以及错误信息的自定义error_messages。而fields字段表示序列化后用于展示的字段。1234567891011121314151617181920212223242526from rest_framework import serializersfrom article.models import Articleclass ArticleSerializer(serializers.ModelSerializer): desc = serializers.CharField(min_length=10, max_length=100, error_messages=&#123; 'required': '描述必填', 'max_length': '描述不超过100字符', 'min_length': '描述不少于10字符' &#125;) title = serializers.CharField(max_length=10, error_messages=&#123; 'required': '标题必填', &#125;) content = serializers.CharField(min_length=10, error_messages=&#123; 'required': '内容必填', &#125;) class Meta: # 序列化的模型 model = Article # 需要序列化的字段 fields = ['title', 'desc', 'content', 'id', 'atype'] &emsp;&emsp;分析: model: 指明该序列化器处理的数据字段从模型类Article参考生成。 fields: 指明该序列化器包含模型类中的哪些字段，&apos;all&apos;指明包含所有字段。 6. 条件过滤&emsp;&emsp;定义过滤模型的ArticleFiler类，并继承与filters.FilterSet。如下定义过滤的字段title、desc、content、min_time、max_time，且过滤的title、desc、content为模糊搜索。 &emsp;&emsp;定义如下的过滤字段，搜索的URL定义如下所示： http://127.0.0.1/xxx/art/?title=小明&amp;desc=django&amp;content=学习&amp;max_time=2018-12-12&amp;min_time=2018-11-11。该URL表名模糊搜索标题title、desc、content，且创建时间大于2018-11-11且创建时间小于2018-12-12 123456789101112131415161718192021from rest_framework import filtersimport django_filtersfrom article.models import Articleclass ArticleFiler(filters.FilterSet): # 过滤URL中title参数 title = django_filters.CharFilter('title', lookup_expr='contains') # 过滤URL中的desc参数 desc = django_filters.CharFilter('desc', lookup_expr='contains') # 过滤URL中的content参数 content = django_filters.CharFilter('content', lookup_expr='contains') # 过滤URL中时间最小值min_time min_time = django_filters.DateTimeFilter('create_time', lookup_expr='gt') # 过滤URL中时间最大值max_time max_time = django_filters.DateTimeFilter('create_time', lookup_expr='lt') class Meta: model = Article fields = ['title', 'desc', 'content', 'create_time'] 7. 增删改查方法自定义&emsp;&emsp;mixins在djangorestframework中主要配合viewsets共同使用，实现http方法与mixins的相关类与方法进行关联。djangorestframework中有5类Minxin，他们与http方法对应如下: mixins 作用 对应的请求方式 mixins.ListModelMixin 定义一个list方法，返回一个queryset的列表 Get mixins.CreateModelMixin 定义一个create方法，创建一个实例 Post mixins.RetriverModelMixin 定义一个retrieve方法，返回一个具体的实例 Get mixins.UpdateModelMixin 定义一个update方法，对某个实例进行更新 Put/Patch mixins.DestoryModelMixin 定义一个delete方法，删除某个实例 Delete &emsp;&emsp;具体分析： 7.1 CreateModelMixin&emsp;&emsp;源码:12345678910111213141516171819202122232425262728class CreateModelMixin(object): \"\"\" Create a model instance ==&gt;创建一个实例 \"\"\" def create(self, request, *args, **kwargs): # 获取相关serializer serializer = self.get_serializer(data=request.data) # 进行serializer的验证 # raise_exception=True,一旦验证不通过，不再往下执行，直接引发异常 serializer.is_valid(raise_exception=True) # 调用perform_create()方法，保存实例 self.perform_create(serializer) headers = self.get_success_headers(serializer.data) return Response(serializer.data, status=status.HTTP_201_CREATED, headers=headers) def perform_create(self, serializer): # 保存实例 serializer.save() def get_success_headers(self, data): try: return &#123;'Location': str(data[api_settings.URL_FIELD_NAME])&#125; except (TypeError, KeyError): return &#123;&#125; &emsp;&emsp;创建的逻辑思路图如下: &emsp;&emsp;分析: 由上图可以看出这个类的一个逻辑，其中，perform_create( )对serializer直接进行save保存，当在一些情境下，我们需要对perform_create( )进行重写。 &emsp;&emsp;那么我们现在可能有一个下面的需要： &emsp;&emsp;假设现在有一个course课程model，里面维持了一个数，记录课程收藏数，还存在一个用户收藏userfav的model(外键course指向课程模型)，当一个用户对课程进行收藏，理论上现在post进来的应该是userfav的instance，显然，我们还需要对相应course的收藏数fav_num进行+1。 这个时候，我们就需要重写perform_create( )方法！ 123456def perform_create(self, serializer): # 重写save的逻辑 instance = serializer.save() course = instance.course course.fav_num += 1 course.save() 7.2 ListModelMixin&emsp;&emsp;源码:12345678910111213141516171819class ListModelMixin(object): \"\"\" List a queryset.==&gt; 列表页获取 \"\"\" def list(self, request, *args, **kwargs): queryset = self.filter_queryset(self.get_queryset()) # 这是一个分页功能，如果在viewset中设置了pagination_class，那么这里就会起作用 # 获取当前页的queryset，如果不存在分页，返回None page = self.paginate_queryset(queryset) if page is not None: # 分页不为空，那么不能简单的执行Response(serializer.data) # 还需要将相关的page信息序列化在进行响应 serializer = self.get_serializer(page, many=True) return self.get_paginated_response(serializer.data) serializer = self.get_serializer(queryset, many=True) return Response(serializer.data) 分析: ListModelMixin一般用来获取列表页，大多数情况下比较简单，不需要重写相关的方法。 7.3 RetrieveModelMixin&emsp;&emsp;源码:12345678910class RetrieveModelMixin(object): \"\"\" Retrieve a model instance.==&gt; 获取某一个对象的具体信息 \"\"\" def retrieve(self, request, *args, **kwargs): # 一般访问的url都为/obj/id/这种新式 # get_object()可以获取到这个id的对象 instance = self.get_object() serializer = self.get_serializer(instance) return Response(serializer.data) &emsp;&emsp;分析: 访问的URL都为/obj/id/这种新式才会调用该retrieve方法，其中get_object()可以获取到这个id的对象。开发中对retrieve这个方法的重写几率比较高，例如我们在增加点击数的时候，经常要对其进行一个重写。 7.4 UpdateModelMixin&emsp;&emsp;源码:123456789101112131415161718192021222324class UpdateModelMixin(object): \"\"\" Update a model instance.==&gt; 更新某个具体对象的内容 \"\"\" def update(self, request, *args, **kwargs): partial = kwargs.pop('partial', False) instance = self.get_object() serializer = self.get_serializer(instance, data=request.data, partial=partial) serializer.is_valid(raise_exception=True) self.perform_update(serializer) if getattr(instance, '_prefetched_objects_cache', None): # If 'prefetch_related' has been applied to a queryset, we need to # forcibly invalidate the prefetch cache on the instance. instance._prefetched_objects_cache = &#123;&#125; return Response(serializer.data) def perform_update(self, serializer): serializer.save() def partial_update(self, request, *args, **kwargs): kwargs['partial'] = True return self.update(request, *args, **kwargs) &emsp;&emsp;分析: UpdateModelMixin实现逻辑基本整合了Create以及Retrieve，先得到具体的实例，再对其进行验证以及保存，如果需要对更新这个逻辑进行自定义，那么需要重写perform_update( )方法，而尽量少去重写update( ) 7.5 DestroyModelMixin&emsp;&emsp;源码:1234567891011class DestroyModelMixin(object): \"\"\" Destroy a model instance. \"\"\" def destroy(self, request, *args, **kwargs): instance = self.get_object() self.perform_destroy(instance) return Response(status=status.HTTP_204_NO_CONTENT) def perform_destroy(self, instance): instance.delete() &emsp;&emsp;DestroyModelMixin的逻辑也相对比较简单，当删除文章对象数据时，通过修改模型中的定义的is_delete字段，将is_delete字段置为1表示删除数据,这是逻辑删除，并不是物理删除。因此重构perform_destroy方法，如下:123def perform_destroy(self, instance): instance.is_delete = 1 instance.save() 8. to_representation方法&emsp;&emsp;概念:序列化器的每个字段实际都是由该字段类型的to_representation方法决定格式的，可以通过重写该方法来决定格式。 &emsp;&emsp;如下重定义to_representation方法，把每一列数据（其中instance代表每一列数据）进行修改重组，然后返回，如下示例将返回文章的类型字段进行修改再填充回数据中进行返回。12345678910111213141516171819202122232425262728293031323334from rest_framework import serializersfrom article.models import Articleclass ArticleSerializer(serializers.ModelSerializer): desc = serializers.CharField(min_length=10, max_length=100, error_messages=&#123; 'required': '描述必填', 'max_length': '描述不超过100字符', 'min_length': '描述不少于10字符' &#125;) title = serializers.CharField(max_length=10, error_messages=&#123; 'required': '标题必填', &#125;) content = serializers.CharField(min_length=10, error_messages=&#123; 'required': '内容必填', &#125;) class Meta: # 序列化的模型 model = Article # 需要序列化的字段 fields = ['title', 'desc', 'content', 'id', 'atype'] def to_representation(self, instance): # 序列化是会默认调用该方法，返回的结果为当前instance对象的序列化结果 data = super().to_representation(instance) if instance.atype: data['atype'] = instance.atype.t_name return data 9. get_queryset方法&emsp;&emsp;get_queryset(self)：返回视图使用的查询集，是列表视图与详情视图获取数据的基础，默认返回queryset属性，可以重写，例如对查询结果集进行再次过滤，可以重写如下：123def get_queryset(self): queryset = self.queryset return queryset.filter(title__contains='django学习day01') 10. get_object方法&emsp;&emsp;get_object(self): 返回详情视图所需的模型类数据对象。在视图中可以调用该方法获取详情信息的模型类对象。若详情访问的模型类对象不存在，会返回404。","tags":[{"name":"Django","slug":"Django","permalink":"http://yoursite.com/tags/Django/"}]},{"title":"装饰器、中间件和Session","date":"2018-12-03T12:08:50.000Z","path":"2018/12/03/装饰器、中间件和Session/","text":"装饰器、中间件和Session的使用 一、装饰器1.1 什么是装饰器 装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。 这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。 1.2 装饰器的三个基本点1、外层函数内嵌内层函数 2、外层函数返回内层函数 3、内层函数调用外层函数的参数 &emsp;&emsp;例如：12345678910111213141516# 定义登录验证的装饰器def is_login(func): # func 就是被装饰的函数（function类型） def check_status(request): token = request.COOKIES.get('token') if token: token_user = TokenUser.objects.filter(token=token).first() if token_user: # 返回func(request)表示继续执行被装饰的函数 return func(request) else: return HttpResponseRedirect('/login/') else: return HttpResponseRedirect('/login/') return check_status &emsp;&emsp;注意：在上面的函数中外层函数的形参func指的是饰器装饰的函数，是一个function对象。return func(request)表示继续执行被装饰函数（如果需要继续执行被装饰函数就应该这样写），由于被装饰的函数有一个形参request，所以需要传入这个request参数，根据具体函数情况而定，也可以其他的执行操作。 &emsp;&emsp; 装饰器优点：利用装饰器可以替代我们纯手写的登录校验代码，同时装饰器有较高的灵活性，耦合性低，减少代码重复。 &emsp;&emsp; 装饰器缺点：多层装饰比较复杂。 二、中间件2.1 什么是中间件：&emsp;&emsp;面向切面编程AOP中的中间件是一个最好的例子。官方的说法：中间件是一个用来处理Django的请求和响应的框架级别的钩子。它是一个轻量、低级别的插件系统，用于在全局范围内改变Django的输入和输出。 2.2 中间件Middleware描述中间件： 1. 是一个轻量级的，底层的插件，可以介入Django的请求和响应的过程（面向切面编程) 2. 中间件的本质就是一个python类 &emsp;&emsp;注意：中间件是帮助我们在视图函数执行之前和执行之后都可以做一些额外的操作，它本质上就是一个自定义类，类中定义了几个方法，Django框架会在请求的特定的时间去执行这些方法。 2.3 中间件中的方法&emsp;&emsp; 每个中间j件都是一个独立的类，主要有一下几个方法 1. process_requeest(self, request) 该方法是在Django接收到request之后，但仍未解析出url以确定运行哪个视图函数view视图函数之前。 2. process_view(self, request, view_func, view_args, view_kwargs) 执行时机在django执行完request预处理函数并确定待执行的view之后, 但在视图函数view之前 request: HttpRequest对象 view_fun: 是django将要调用的视图函数, 是真实的函数对象本身 view_args: 将传入view的位置参数列表, 不包括request参数 view_kwargs: 将传入view的字典参数 3. process_response(self, request, response) 该方法必须返回HttpResponse对象, 可以是原来的, 也可以是修改后的 调用时机在django执行完view函数并生成response之后, 该中间件能修改response的内容, 常见用途比如压缩内容 request是request对象 response是从view中返回的response对象 4. process_exception(self, request, exception) 默认不主动调用，该方法只有在request处理过程中出了问题并且view函数抛出了一个未捕获的异常才会被调用, 可以用来发送错误通知, 将相关信息输出到日志文件, 或者甚至尝试从错误中自动恢复。 参数包括request对象, 还有view函数抛出的异常对象exception 必须返回None或HttpResponse对象 5. process_template_response(self, request, response) 默认不主动调用，在视图执行render()返回后进行调用，必须返回None或HttpResponse对象 &emsp;&emsp;注意：以上方法的返回值可以是None或一个HttpResponse对象，如果是None，则继续按照django定义的规则向后继续执行，如果是HttpResponse对象，则直接将该对象返回给用户。 &emsp;&emsp; 具体函数解释： 1. process_request()函数 process_request方法中有一个request参数，其表示请求。该方法中可以返回None或不用返回任何参数，或返回HttpResponse对象。如果返回None或不返回任何参数则表示继续执行其余中间件，如果是返回HttpResponse对象则直接返回HttpResponse对象给客户端，而不再执行视图函数。 2. process_response(self, request, response)函数 process_ response方法中两个参数，一个是请求request参数，一个是响应response参数，该response参数就是视图函数返回的HttpResponse对象。 &emsp;&emsp; 修改中间件TestMiddlware1和TestMiddlware2，修改代码如下：1234567891011121314151617class TestMiddlware1(MiddlewareMixin): def process_request(self, request): print('test1 process_request') def process_response(self, request, response): print('test1 process_response') return responseclass TestMiddlware2(MiddlewareMixin): def process_request(self, request): print('test2 process_request') def process_response(self, request, response): print('test2 process_response') return response &emsp;&emsp; 访问inde路由地址，在控制台中可以打印如下的内容: test1 process_request test2 process_request index views test2 process_response test1 process_response &emsp;&emsp; 从结果中可以发现，中间件的process_request在访问视图函数之前执行，而process_reponse在视图函数之后执行。并且从执行顺序中可以得出以下结论: 1） 多个中间件的process_request的执行顺序是按照在MIDDLEWARE中定义的先后顺序执行的。 2） 多个中间件的process_response的执行顺序是按照MIDDLEWARE中定义的顺序逆序执行的。也就是说第一个中间件的process_request先执行，而第一个中间件的process_response最后执行。 3） 视图函数在process_request之后执行。 4） 视图函数在process_response之前执行。 5） process_response必须返回响应对象。 3. process_view(self, view_func, view_args, view_kwargs) 讲解及处理流程 &emsp;&emsp; 该方法接收四个参数: 请求request view_func: 即将被执行的函数 view_args：传递给视图函数的列表参数 view_kwargs：传递给视图函数的字典参数 &emsp;&emsp; 修改中间件TestMiddlware1和TestMiddlware2，修改代码如下：1234567891011121314151617181920212223class TestMiddlware1(MiddlewareMixin): def process_request(self, request): print('test1 process_request') def process_response(self, request, response): print('test1 process_response') return response def process_view(self, request, view_func, view_args, view_kwargs): print('test1 process_view')class TestMiddlware2(MiddlewareMixin): def process_request(self, request): print('test2 process_request') def process_response(self, request, response): print('test2 process_response') return response def process_view(self, request, view_func, view_args, view_kwargs): print('test2 process_view') &emsp;&emsp; 访问index路由地址，在控制台中可以打印如下的内容: test1 process_request test2 process_request test1 process_view test2 process_view index views test2 process_response test1 process_response &emsp;&emsp; 从结果中可以发现，中间件中的process_view方法在视图函数之前执行，在process_request方法之后执行，process_view执行的顺序按照MIDDLEWARE中定义中间件的顺序执行的。并且从执行的结果中可以得出以下结论: 1） process_request执行后才执行process_view 2） 视图函数在process_view方法执行后执行 3） process_view方法在process_response方法之后执行，并且执行的顺序按照MIDDLEWARE中定义中间件的顺序执行 4. process_template_response(self, request, response) 讲解及处理流程 该方法中接收两个参数，一个是请求request，一个是响应response，该响应response由视图函数产生。process_template_response方法默认是不执行的，只会在视图函数返回对象有一个render方法时才会被调用。 &emsp;&emsp; 修改index视图函数 rep = HttpResponse() rep.render = index_render return rep &emsp;&emsp; 修改中间件TestMiddlware1和TestMiddlware2，修改代码如下：12345678910111213141516171819202122232425262728293031323334353637class TestMiddlware1(MiddlewareMixin): def process_request(self, request): print('test1 process_request') def process_response(self, request, response): print('test1 process_response') return response def process_view(self, request, view_func, view_args, view_kwargs): print('test1 process_view') def process_exception(self, request, exception): print('test1 process_except') def process_template_response(self, request, response): print('test1 process_template_response') return responseclass TestMiddlware2(MiddlewareMixin): def process_request(self, request): print('test2 process_request') def process_response(self, request, response): print('test2 process_response') return response def process_view(self, request, view_func, view_args, view_kwargs): print('test2 process_view') def process_exception(self, request, exception): print('test2 process_except') def process_template_response(self, request, response): print('test2 process_template_response') return response &emsp;&emsp; 访问index路由地址，在控制台中可以打印如下的内容: test1 process_request test2 process_request test1 process_view test2 process_view index views test2 process_template_response test1 process_template_response test2 process_response test1 process_response &emsp;&emsp; 从结果中可以得出以下结论: 1） process_template_response在视图函数执行完后。并且执行的顺序按照MIDDLEWARE中定义中间件的顺序逆序执行。 2） process_response方法是最后执行的，并且执行的顺序按照MIDDLEWARE中定义中间件的顺序逆序执行。 5. process_exception(self, request, exception) 讲解及处理流程 该方法中接收两个参数，一个是请求request，一个是异常exception，该exception是视图函数产生的异常Exception对象。process_exception方法默认是不执行的，只会在视图函数出现异常的情况才会执行。 &emsp;&emsp; 修改index视图函数，使得index方法抛出一个异常:12345def index(request): if request.method == 'GET': print('index views') 1/0 return HttpResponse('我是index方法') &emsp;&emsp; 修改中间件TestMiddlware1和TestMiddlware2，修改代码如下：1234567891011121314151617181920212223242526272829class TestMiddlware1(MiddlewareMixin): def process_request(self, request): print('test1 process_request') def process_response(self, request, response): print('test1 process_response') return response def process_view(self, request, view_func, view_args, view_kwargs): print('test1 process_view') def process_exception(self, request, exception): print('test1 process_except')class TestMiddlware2(MiddlewareMixin): def process_request(self, request): print('test2 process_request') def process_response(self, request, response): print('test2 process_response') return response def process_view(self, request, view_func, view_args, view_kwargs): print('test2 process_view') def process_exception(self, request, exception): print('test2 process_except') &emsp;&emsp; 访问index路由地址，在控制台中可以打印如下的内容: test1 process_request test2 process_request test1 process_view test2 process_view index views test2 process_except test1 process_except test2 process_response test1 process_response &emsp;&emsp; 从结果中可以得出以下结论: 1） process_request最先执行。并且执行的顺序按照MIDDLEWARE中定义中间件的顺序执行。 2） process_view在视图函数之前执行，并且执行的顺序按照MIDDLEWARE中定义中间件的顺序执行。 3） 视图函数在process_view方法执行后执行，在process_exception方法之前执行。 4） process_exception方法在process_response方法之前执行，并且执行的顺序按照MIDDLEWARE中定义中间件的顺序逆序执行。 5） process_response方法是最后执行的，并且执行的顺序按照MIDDLEWARE中定义中间件的顺序逆序执行。 三、cookie + session实现登录的保持&emsp;&emsp; 在为引入装饰器和中间件之前，对于登录状态的保持我们都是自己在需要进行登录校验的视图函数中添加登录校验代码，采用的是cookie的形式。这样会产生大量的重复代码，所以我们引入中间和装饰器，减少代码重复。 由于cookie这种保持登录状态存在安全隐患，所以下面我们才有session和csrf进行登录状态保持 session指的是回话，是指当用户请求时服务端和客户端会建立一个回话连接，当用户发送其他请求时会携带服务器端返回的session_key（一串随机数）来发送请求，服务端去Django维持的Django_session数据库表中查询是否有该key所对应的数据，有则允许访问，否则不能访问。 &emsp;&emsp; 使用request.session向session中写入session值 # 使用session实现登录操作 # 1. 向cookie中设置session值，value为随机字符串 # 2. 向Django_session表中存入sessionid值 request.session[&apos;user_id&apos;] = user.id &emsp;&emsp; 这里设置的session值一般为主键，因为我们可以通过主键获取到一个user对象，方便与我们后面取值，推荐使用。 &emsp;&emsp; 结合中间件或者装饰器我们可以减少跟多的代码，下面是采用中间件进行登录校验 123456789101112131415161718192021222324252627282930313233class LoginStatusMiddleware(MiddlewareMixin): def process_request(self, request): # 在访问登录和注册页面的时候都不需要进行登录校验 if request.path in ['/login/', 'redister']: return None # 这个函数的return可写可不写，推荐不写 # 登录校验，当访问需要登录才能访问的页面时就需要进行登录校验，登录了就能访问，未登录就不能访问 # token校验 # token = request.COOKIES.get('token') # if token: # token_user = TokenUser.objects.filter(token=token).first() # if not token_user: # return HttpResponseRedirect('/login/') # else: # return HttpResponseRedirect('/login/') # session校验 # 1. 获取cookie中的值， # 2. 查询Django_session表中的session_key字段 # 查询大数据，则获取session_data中存入的键值对 user_id = request.session.get('user_id') if user_id: user = MyUser.objects.get(pk=user_id) request.user = user return None else: return HttpResponseRedirect('/login/') def process_response(self, request, response): print('reponse') return response &emsp;&emsp; 在上面定义的中间件类中我们通过request.sessions.get(‘user_id’)进行session校验，如果用户登录就能在Django_session表中获取到相应的session数据,这样一句就相当于我们上面写的token检验等功能，但是代码量更少，可读性跟高。装饰器同样的方式即可。 四、session的常用操作1. 设置sessionsession是键值对的形式存储的，所以可以用以下方法设置session request.session[&apos;键名&apos;] = value 如： request.session[&apos;user_id&apos;] = user.id 2. 获取session值通过request.session.get()获取session值 格式： request.session.get(key) 如： request.session.get(&apos;user_id&apos;) 3. 删除session值删除Django_session表中的值 # 仅仅只删除Django_session表中的数据 request.session.delete(request.session.session_key) # 删除客户端和服务端session表中的值 # request.session.flush()","tags":[{"name":"Django","slug":"Django","permalink":"http://yoursite.com/tags/Django/"}]},{"title":"cookie的使用","date":"2018-11-30T12:04:21.000Z","path":"2018/11/30/cookie的使用/","text":"cookie的使用–简单登录注册实现 一、登录&emsp;1.1 HTTP是无状态协议，无法保存用户的登录状态可以用cookie 存储用户的信息 -- 但是这种方式并不安全 所以后面采用 cookie + session 解决这种不安全，同时可以保持用户登录状态 登录时需要向cookie中设置一个随机字符串（token）令牌 token令牌: 是在用户登录成功后服务器返回的一个标识符，但是令牌有有效时间限制 &emsp;1.2 如何向cookie中存数据（令牌）&emsp;&emsp;在Django中可以从用户的请求中获取cookie值，下面采用登录注册为实例说明cookie的应用 当用户发出登录请求时，服务器获取请求，如果登录成功服务器会向用户返回一个响应，并将登录的令牌一同返回回去 #获取响应 res = HttpResponse() # 设置cookie res.set_cookie(&apos;token&apos;, value，有效时间（秒）) 如： res.set_cookie(&apos;token&apos;, &apos;123123&apos;，600) 参数解释： 绑定参数到cookie中 key表示设置的名称 value表示设置的值 max_age表示多少秒后过期 expires表示datetime类型的日期， 表示多久过期 &emsp;1.3 如何做令牌校验&emsp;&emsp;做令牌校验需要先获取cookie值 &emsp;&emsp;在了解如何会获取cookie值前我们需要先了解request请求中的内容主要有哪些 字段 说明 COOKIE 传递客户端中的cookie内容 GET 获取HTTP GET请求中传递的参数。如：127.0.0.1/xxx/id=1 POST 获取HTTP POST请求中传递的参数 FILES 获取请求页面中的文件 path 获取当前请求的url路径 method 获取请求方式 &emsp;&emsp;获取cookie值： 由于请求中的cookie值是以字典的形式传给服务器，服务器可以通过字典取值的方式获取值，但推荐用get方式获取（但键不存在时不会报错） # GET 请求获取 token = request.GET.get(&apos;token&apos;) # POST 请求获取 token = request.POST.get(&apos;token&apos;) &emsp;&emsp;要做保持用户登录状态，则需要保存用户的cookie值，由于用户和cookie值之间是一对一的关系，可以考虑建一张token表用于保存用户cookie值,并做一对一关联 123class TokenUser(models.Model): token = models.CharField(max_length=30) user = models.OneToOneField(MyUser) &emsp;&emsp;但是由于每个用户登录后都会获取不同的cookie值，我们可以运用随机函数（random）产生，在开发中像这样的功能函数我们可以创建一个文件夹来保存这些工具（函数）。 在项目文件夹下创建一个名为utils的文件夹，我们把一些共用的函数放在这个文件夹下，同时还需要创建一个__init__.py文件（目的是告诉解释器把这个文件看成一个python包） &emsp;1.4 令牌校验成功与否后的操作&emsp;&emsp;假设登录后才能访问首页，要判断用户是否登录则需要在cookie有效时间内判断用户的请求是否有有效的cookie值，该cookie可以在数据中读取。 123456789def my_index(request): # 当访问127.0.0.1/my_index/ 时如果用户登录过，并且cookie有效，则跳转到index.html页面，否则返回登录页面 if request.method == 'GET': token = request.COOKIES.get('token') user_token = TokenUser.objects.filter(token=token) if user_token: return render(request, 'index.html') else: return HttpResponseRedirect('/login/') 注意： 当用render()返回页面时，浏览器的url不会改变成相应的url，所有这里需要用跳转 如： return render(request, &apos;index.html&apos;) return HttpResponseRedirect(&apos;/login/&apos;) 二、简单用户注册和登录&emsp;&emsp;用户注册：通过前端form表单向服务器提交用户注册信息，服务器通过request请求获取对应的信息，并在后端进行用户信息校验，并做出不同的响应。 &emsp;&emsp;用户登录：用户通过前端form表单向服务器提交登录信息，服务器通过request请求获取对应的登录信息，并在后端做用户登录信息校验，做出不同的响应，并返回用户此次登录的cookie值，用于保存用户登录状态。 &emsp;&emsp;用户注册：12345678910111213141516171819202122232425262728293031def register(request): if request.method == 'GET': # GET 访问 127.0.0.1/redister/ return render(request, 'register.html') if request.method == 'POST': username = request.POST.get('username') password = request.POST.get('password') password2 = request.POST.get('password2') # 判断用户名是否注册 re = MyUser.objects.filter(username=username).first() if re: err_name = '该用户已经被注册！' return render(request, 'register.html', &#123;'err_name': err_name&#125;) # 判断密码和确认密码是否相同 if password and password2: if password != password2: err_pwd = '两次密码输入不一致！' return render(request, 'register.html', &#123;'err_name': err_pwd&#125;) else: # 如果用户名存在，且密码和确认密码相同，则注册保存 MyUser.objects.create(username=username, password=password) # return render(request, 'login.html') # 跳转指定的地址页面 return HttpResponseRedirect('/login/') else: err_pwd = '密码不能为空！' return render(request, 'register.html', &#123;'err_name': err_pwd&#125;) &emsp;&emsp;用户登录：12345678910111213141516171819202122232425262728def login(request): if request.method == 'GET': return render(request, 'login.html') if request.method == 'POST': # 获取用户账号密码信息 username = request.POST.get('username') password = request.POST.get('password') # 验证是否输入账号密码 if not (username and password): return render(request, 'login.html', &#123;'err_name': '用户名或密码不能为空！'&#125;) # 判断是否有该用户的信息 user = MyUser.objects.filter(username=username, password=password).first() if not user: return render(request, 'login.html', &#123;'err_name': '该用户未注册！'&#125;) # 登录验证并给他一个令牌 res = HttpResponseRedirect('/my_index/') token = get_cookie_token() res.set_cookie('token', token, 600) token_user = TokenUser.objects.filter(user=user).first() if token_user: token_user.token = token else: TokenUser.objects.create(user=user, token=token) return res","tags":[{"name":"Django","slug":"Django","permalink":"http://yoursite.com/tags/Django/"}]},{"title":"模板基础","date":"2018-11-29T11:29:15.000Z","path":"2018/11/29/模板基础/","text":"模板基础用法、使用模板时的一些注意事项 一、模板基础&emsp;&emsp;1.1 在项目文件夹下创建一个templates文件夹&emsp;&emsp;1.2 在项目文件夹下的setting.py文件中TEMPLATES中添加&apos;DIRS&apos;: [os.path.join(BASE_DIR, &apos;templates&apos;)] &emsp;&emsp;如下：123456TEMPLATES = [ &#123; # 此处省略部分代码 'DIRS': [os.path.join(BASE_DIR, 'templates')] # 此处省略部分代码&#125; &emsp;&emsp;作用：‘DIRS’: [os.path.join(BASE_DIR, ‘templates’)] 这是告诉Django在当前项目路径下去找templates模板 二、模板使用&emsp;&emsp;2.1 创建模板在上面创建的文件夹下创建模板文件（html文件）用于渲染内容 在此之前需要先配置url和定义对应的视图函数 在项目文件夹下urls.py中添加 url(r&apos;^index&apos;, views.index) 并定义相应的index视图函数 &emsp;&emsp;如：123def index(request): stus = Student.objects.all() return render(request, 'index.html', &#123;'students': stus&#125;) render() 用于指定渲染页面的模板是哪个 模板中大部分都是html标签，最主要就是当模板拿到视图函数传入的数据时该如何解析 &emsp;&emsp;2.2 模板解析解析变量： {{ 变量 }} 解析标签： {% 标签 %} 标签有 for/if 等 {% for %} {% endfor %}/{% if %} {% endif %} endfor/endif 必须写 &emsp;&emsp;2.3 模板中的注释123456&lt;!-- 注释1 --&gt; 原生html注释会被浏览器解释，当查看源码时会显示 &#123;# 注释2 #&#125; 不会被浏览器解释并且不会在源码中显示&#123;% comment %&#125; 多行注释不会被浏览器解释并且不会在源码中显示 &lt;p&gt;注释3&lt;/p&gt; &lt;a&gt;注释4&lt;/a&gt;&#123;% endcomment %&#125; &emsp;&emsp;2.4 模板循环变量 模板变量 说明 forloop.counter 从1开始计数 forloop.counter0 从0开始计数 forloop.revcounter 倒序1结束 forloop.revcounter0 倒序0结束 forloop.first 第一个是true其他都为false forloop.last 最后一个是true其他都为false &emsp;在开发中模板界面不止一个，并且可能会有大量重复代码，我们可以考虑用模板继承，减少重复代码 &emsp;&emsp;2.5 基础模板&emsp;定义一个母版(base.html) 在母版中通过 进行占位，当子页面继承该母版时只需用相应的内容填充该位置即可,这种方式也称为挖坑 &emsp;具体如下： 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt; &#123;% block title %&#125; &#123;% endblock %&#125; &lt;/title&gt; &#123;% block css %&#125; &#123;% endblock %&#125; &#123;% block js %&#125; &#123;% endblock %&#125;&lt;/head&gt;&lt;body&gt; &#123;% block content %&#125; &#123;% endblock %&#125;&lt;/body&gt;&lt;/html&gt; &emsp;&emsp;在母版中可以添加相应的内容，但是一般不这么做因为母版只负责占位(挖坑)，如果有些内容在很多页面都要用到，可以在定义一个模板，让其继承母版，再把需要用的内容添加在该模板中，让其他渲染模板继承这个模板。&emsp;&emsp;注意： 如果渲染模板继承上面的模板，可以保留父模板的内容，也可以重新填充。 保留父模板内容： ，同时也可以写自己的内容 &emsp;&emsp;比如jQuery是公共的js文件，但是有些页面也有自己的js，此时就可以把jQuery放在母版的第一个孩子（模板）中，通过保留，然后在写自己的js, 但是注意不用super直接写会把父模板的内容覆盖。","tags":[{"name":"Django","slug":"Django","permalink":"http://yoursite.com/tags/Django/"}]},{"title":"模型关系之一对多","date":"2018-11-29T11:25:19.000Z","path":"2018/11/29/模型关系之一对多/","text":"模型关系之一对多 一、一对多关系中的反正向查询&emsp;&emsp;1.1 定义学生和班级模型123456789101112131415class Grade(models.Model): gname = models.CharField(max_length=20) create_time = models.DateField(auto_now_add=True) class Meta: db_table = 'tb_grade'class Student(models.Model): name = models.CharField(max_length=10, unique=True) # 定义外键(一对多关系中外键在多的一边) grade = models.ForeignKey(Grade, null=True) class Meta: # 指定Student模型映射到数据库中时，对应的表名。 db_table = 'tb_student' &emsp;&emsp;1.2 对学生和班级进行反正向查询12345678910111213141516# 正向查询def sel_grade_by_stu(request): \"\"\"通过学生查对应的班级\"\"\" stu = Student.objects.filter(name='大明').first() stu_grade = stu.grade gname = stu_grade.gname return HttpResponse(f'&#123;stu.name&#125;\\t&#123;gname&#125;')# 反向查询def sel_stu_by_grade(request): \"\"\"通过班级查询班级所有学生\"\"\" grade = Grade.objects.filter(id=15).first() stus = grade.student_set.all() names = [stu.name for stu in stus] return HttpResponse(f'&#123;names&#125;') 一对多关联查询时，当多的查一的需要用 对象.模型名小写 如：stu.grade 当一的查多的需要用 对象.模型名_set（返回的是关联关系） 如： grade.student_set.all() 查看所有的查询集 二、多对多关联查询&emsp;&emsp;2.1 在上面的基础上再创建一个课程模型（学生和课程就是多对多关系）1234567class Course(models.Model): cname = models.CharField(max_length=10) # 定义多对多关联 stu = models.ManyToManyField(Student) class Meta: db_table = 'tb_course' 注意：ManyToManyField 字段定义在需要关联的任何一个模型中都可以，迁移时会产生一张第三张表,用于维持多对多关系 此时多对多关系就可以看成第三表和另外两张表的两个一对多关系 &emsp;&emsp;2.2 多对多关联查询通过学生查询学生课程，并添加课程 stu = Student.objects.filter(name=&apos;大明&apos;).first() cou = Course.objects.filter(cname=&apos;高数&apos;).first() # 添加课程 add(对象) # stu.course_set.add(cou) # 移除课程 remove(对象) stu.course_set.remove(cou) 多对多关联查询与一对多关系中的反正向查询类似，主要注意set的使用情况","tags":[{"name":"Django","slug":"Django","permalink":"http://yoursite.com/tags/Django/"}]},{"title":"ORM查询数据操作","date":"2018-11-28T03:43:48.000Z","path":"2018/11/28/ORM查询数据操作/","text":"ORM查询数据操作 一、ORM查询数据库1.1 filter()过滤器 – 精确查询&emsp;作用： 返回符合条件的数据 对象.objects.filter(筛选条件): 查询满足条件的查询集 1.2 获取所有数据 对象.objects.all() : 返回数据库中所有数据集 1.3 获取满足条件的数据 对象.objects.get(筛选条件)： &emsp;注意：获取满足条件的对象，但是查询条件必须存在，并且查询数据条数为1条，否则都会报错而filter()当查询条件不存在时返回空查询集，数据条数大于1时，返回一个列表类型的查询集 对象.objects.exclude(过滤条件)返回不满足条件的结果集（QuerySet），也可以说是过滤掉满足条件的结果集 1.4 组合条件查询&emsp;&emsp;如：1234# 查询年龄等于18且性别为女的学生信息stus = Student.objects.filter(age=18).filter(gender=0)# 多个条件可以写在一个filter中（推荐使用）stus = Student.objects.filter(age=18, gender=0) 二、 从查询集中获取数据&emsp;2.1 下标获取 stus = Student.objects.all()如： stus[0]但是注意下标越界异常 &emsp;2.2 first() 获取第一个元素 如： stus.first() &emsp;2.3 last() 获取最后一个元素 如： stus.last() 三、 排序 order_by 对象.objects.order_by(排序字段) &emsp;&emsp;如： 1234stus = Student.objects.all().order_by('-id') # 排序 order_by # 降序 -id 在sql中 id desc # 升序 id 在sql中 id asc &emsp;&emsp;测试可以通过values()获取对象键值对 如：stus.values() 限制查询集，可以使用下标的方法进行限制，等同于sql中的limit模型名.objects.all()[0:5] 小标不能为负数 函数 说明 first() 返回查询集中的第一个对象 last() 返回查询集中的最后一个对象 count() 返回当前查询集中的对象个数 exists() 判断查询集中是否有数据，如果有数据返回True，没有返回False 四、 模糊查询&emsp; 4.1 contains 包含 类似于 like %小% 如： stus = Student.objects.filter(name__contains=’小’) &emsp; 4.2 endswith 以什么结束 类似于 like %小 如： stus = Student.objects.filter(name_endswith=’明’) &emsp; 4.3 startswith 以什么开头 类似于 like 大% 如： stus = Student.objects.filter(name__startswith=’大’) &emsp;&emsp;注意：以上模糊查询中都对大小写敏感，可以在前面加 i（ignore）忽略大小写（icontains、istartwith、iendswith） &emsp; 4.4 集合运算 – in 如：stus = Student.objects.filter(id__in=[2, 3, 5, 14])stus = Student.objects.filter(pk__in=[2, 3, 5, 14]) &emsp; 4.5 比较运算 gt（大于）、gte（大于等于）、lt（小于）、lte（小于等于） 如：stus = Student.objects.filter(age__gt=18) &emsp; 4.5 聚合 aggreagate()sql中有的聚合函数这里都有（Sum Avg Max Min Count） 需要导入相应的包 from django.db.models import Sum, Avg, Max, Min, Count &emsp;&emsp;如： avg_age = Student.objects.all().aggregate(Avg(‘age’))sum_age = Student.objects.all().aggregate(Sum(‘age’)) &emsp; 4.6 逻辑运算（且（&amp;）、 或（|）、 非（~））逻辑运算需要借助F对象和Q对象，所以需要先导入相应的包 from django.db.models import F, Q &emsp;&emsp;如：1234567891011121314# 查询age=18或者gender=0的学生信息# Q(条件)stus = Student.objects.filter(Q(age=18), Q(gender=0)) # 相当于与（&amp;）stus = Student.objects.filter(Q(age=18) &amp; Q(gender=0))stus = Student.objects.filter(Q(age=18) | Q(gender=0))stus = Student.objects.filter(~Q(age=18) &amp; Q(gender=1))# F() 对象# 查询语文成绩比数学成绩大的学生信息stus = Student.objects.filter(yuwen__gt=F('shuxue'))# 查询语文成绩比数学成绩大10分的学生信息stus = Student.objects.filter(yuwen__gt=F('shuxue') + 10)# F对象支持数学运算 小结 条件 说明 exact、iexact 精确匹配、忽略大小写的精确匹配查询 contains、icontains、startswith、istartswith、endswith、iendswith 基于like的模糊查询 in 集合运算 gt、gte、lt、lte 大于、大于等于、小于、 小于等于关系运算 range 指定范围查询（SQL中的between…and…） year、month、day、week_day、hour、minute、second 查询时间日期 isnull 查询空值（True）或非空值（False） search 基于全文索引的全文检索 regex、iregex 基于正则表达式的模糊匹配查询 六、一对一（OneToOneField）的关联查询&emsp; 6.1 概述： 在python中一对一的关系主要通过OneToOneField来实现，与sql中的外键关联差不多，但是在一对一的关系中外键可以添加在需要关联的任意一个模型中（一对多关系中外键一般加在多的一边） &emsp;例如：123456789101112131415161718# 学生类class Student(models.Model): name = models.CharField(max_length=20) age = models.IntegerField(default=18) class Meta: # 设置表明 db_table = 'tb_student'# 学生信息扩展类class StuInfo(models.Model): phone = models.CharField(max_length=11) address = models.CharField(max_length=31) # 添加外键 stu = models.OneToOneField(Student) class Meta: db_table = 'tb_stuinfo' &emsp;&emsp;注意：OneToOneField等价ForeignKey,且约束unique=True,并且外键映射到数据库中时会键外键字段名默认为 —- 字段_id 如上面定义的stu外键在数据库中为： stu_id ####&emsp; 6.2 正向关联查询 子表查询主表为 — 正向查询 主表查询子表为 — 反向查询&emsp;&emsp;如：12345# 正向查询# 查询电话为10011的学生姓名（子表查主表）stu_info = StuInfo.objects.filter(phone='10011').first()stu = stu_info.stuname = stu.name ####&emsp; 6.2 反向关联查询&emsp;&emsp;如：12345# 反向查询 # 查询名字为小明的学生电话name='小明' stu = Student.objects.filter(name='小明').first() stu_info = stu.stuinfo phone = stu_info.phone","tags":[{"name":"Django","slug":"Django","permalink":"http://yoursite.com/tags/Django/"}]},{"title":"认识Django模型","date":"2018-11-27T12:54:38.000Z","path":"2018/11/27/认识Django模型/","text":"Django简单模型认识和创建模型、生成迁移文件、制作迁移 一、模型介绍&emsp;1. 创建一个简单的学生模型1234567891011121314class Student(models.Model): # 继承models.Model # 定义数据字段 name = models.CharField(max_length=10, unique=True) age = models.IntegerField(default=18) gender = models.BooleanField(default=1) # 创建数据时间，默认为当前时间： auto_now_add=True create_time = models.DateTimeField(auto_now_add=True, null=True) # auto_now : 修改时间， 每次修改学生信息时，修改该字段的时间为当前时间 operate_time = models.DateTimeField(auto_now=True, null=True) class Meta: # 指定Student模型映射到数据库中时，对应的表名。 db_table = 'tb_student' 2. 配置数据库 2.1 在项目文件夹下的setting.py中修改数据库类型和配置数据库连接信息 &emsp;&emsp;如：12345678910DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'NAME': 'dj7', 'USER': 'root', 'PASSWORD': '123456', 'HOST': 'localhost', 'PORT': 3306 &#125;&#125; 2.2 其次需要在项目文件夹下的init.py中添加对应的数据库驱动 mysql如下： import pymysql (如果没有pymysql的需要安装pymysql第三方库)pymysql.install_as_MySQLdb() &emsp;3. 注册应用 在项目文件下的setting.py文件中的INSTALLED_APPS最后添加应用名 &emsp;&emsp;如：1234INSTALLED_APPS = [ 这里省略部分默认代码 'app'] &emsp;4. 生成迁移文件 格式： python manage.py makemigrations 此时会在项目文件夹下的migration文件夹下创建一个迁移文件 如：0001_initial.py &emsp;5. 制作迁移 格式： python manage.py migrate 此时在数据库中就会创建一张与模型向对应的数据库表（其中自动创建一个id字段并且自动增长和是主键） 二、更改启动服务的ip和端口 格式：python manage.py runserver ip:port或者格式：python manage.py runserver port &emsp;注意：后面参数可以是IP：port 或者 port，不能只是ip 三、Debug(程序调试) 在自己认为可能出现错误的地方添加断点，再通过Debug对程序进行检查调试 python中可以通过debug控制台打印程序运行值检查是否出错 四、通过ORM操作数据库(CRUD操作)&emsp;在上面创建的模型基础上通过模型去更改操作数据库表 &emsp;1. 配置url解析12345678910111213# 需要先导入app应用下的views(视图)from app import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), # 新增数据 # 配置url，并调用相应的视图函数 url(r'add_stu/', views.add_stu), # 删除数据 url(r'del_stu/', views.del_stu), # 修改数据 url(r'^up_stu', views.up_stu),] &emsp;2. 在应用(app)文件夹下views.py文件中定义与url相对应的视图函数12345678910111213141516171819202122232425262728293031323334353637383940414243# 引入Student模型from app.models import Studentdef add_stu(request): # 创建向数据库student表中插入数据的函数 # 添加数据 # 方式一： # stu = Student() # stu.name = '小明' # 向数据库中插入数据 # stu.save() # 方式二： Student.objects.create(name='大锤11', age=19) # 返回响应 return HttpResponse('添加成功！')def del_stu(request): # 实现删除数据操作 # 1. 先查询name=‘大锤’的信息 Student.objects.filter(name='大锤11').delete() return HttpResponse('删除成功！')def up_stu(request): # 修改student表中的数据 # 方式一： # stus = Student.objects.filter(name='小明') # 获取小明对象 # stu = stus[0] # stu.name = '大锤' # stu.save() # 方式二： # stu = Student.objects.filter(name='小明').first() # stu.name = '大锤' # stu.save() # 方式三： Student.objects.filter(name='小明').update(name='小明') return HttpResponse('修改成功！') 五、模型中定义的数据类型和数据库（mysql）中的数据类型的关系&emsp;5.1 定义模型 &emsp;&emsp; 1. 字段要求 字段名不能使python的保留字，否则会导致语法错误字段名不能有多个连续下划线，否则会影响ORM查询操作 &emsp;5.2 模型中的数据类型模型字段类型 字段类 说明 AutoField 自增ID字段 BigIntegerField 64位有符号整数 BinaryField 存储二进制数据的字段，对应Python的bytes类型 BooleanField 存储True或False CharField 长度较小的字符串 DateField 存储日期，有auto_now和auto_now_add属性 DateTimeField 存储日期和日期，两个附加属性同上 DecimalField 存储固定精度小数，有max_digits（有效位数）和decimal_places（小数点后面）两个必要的参数 DurationField 存储时间跨度 EmailField 与CharField相同，可以用EmailValidator验证 FileField 文件上传字段 FloatField 存储浮点数 ImageField 其他同FileFiled，要验证上传的是不是有效图像 IntegerField 存储32位有符号整数。 GenericIPAddressField 存储IPv4或IPv6地址 NullBooleanField 存储True、False或null值 PositiveIntegerField 存储无符号整数（只能存储正数） SlugField 存储slug（简短标注） SmallIntegerField 存储16位有符号整数 TextField 存储数据量较大的文本 TimeField 存储时间 URLField 存储URL的CharField UUIDField 存储全局唯一标识符 &emsp;常用的类型主要有以下几类（自己总结的） 类型 说明 自增id字段 AutoField 数字类型 IntegerField、FloatField、DecimalField 字符串类型 CharField、TextField 时间类型 DateField、DateTimeField、TimeField 文件类型 FielField、ImageField 布尔和空 BooleanField、NullBoolField 模型字段属性 选项 说明 null 数据库中对应的字段是否允许为NULL，默认为False blank 后台模型管理验证数据时，是否允许为NULL，默认为False choices 设定字段的选项，各元组中的第一个值是设置在模型上的值，第二值是人类可读的值 db_column 字段对应到数据库表中的列名，未指定时直接使用字段的名称 db_index 设置为True时将在该字段创建索引 db_tablespace 为有索引的字段设置使用的表空间，默认为DEFAULT_INDEX_TABLESPACE default 字段的默认值 editable 字段在后台模型管理或ModelForm中是否显示，默认为True error_messages 设定字段抛出异常时的默认消息的字典，其中的键包括null、blank、invalid、invalid_choice、unique和unique_for_date help_text 表单小组件旁边显示的额外的帮助文本。 primary_key 将字段指定为模型的主键，未指定时会自动添加AutoField用于主键，只读。 unique 设置为True时，表中字段的值必须是唯一的 verbose_name 字段在后台模型管理显示的名称，未指定时使用字段的名称 模型元数据选项选项 | 说明:-:|:-abstract | 设置为True时模型是抽象父类app_label | 如果定义模型的应用不在INSTALLED_APPS中可以用该属性指定db_table | 模型使用的数据表名称db_tablespace | 模型使用的数据表空间default_related_name | 关联对象回指这个模型时默认使用的名称，默认为&lt;model_name&gt;_setget_latest_by | 模型中可排序字段的名称。managed | 设置为True时，Django在迁移中创建数据表并在执行flush管理命令时把表移除order_with_respect_to | 标记对象为可排序的ordering | 对象的默认排序permissions | 创建对象时写入权限表的额外权限default_permissions | 默认为(‘add’, ‘change’, ‘delete’)unique_together | 设定组合在一起时必须独一无二的字段名index_together | 设定一起建立索引的多个字段名verbose_name | 为对象设定人类可读的名称verbose_name_plural | 设定对象的复数名称","tags":[{"name":"Django","slug":"Django","permalink":"http://yoursite.com/tags/Django/"}]},{"title":"初始Django","date":"2018-11-27T10:30:03.000Z","path":"2018/11/27/初始Django/","text":"初识Django和使用Django创建一个简单的web应用 一、命令行安装虚拟环境1. 安装虚拟环境 格式： pip install virtualenv 2.virtualenv 参数解释 -p参数： 指定安装的python版本–no-site-packages参数： 指定安装虚拟环境的空文件夹 二、创建虚拟环境1、命令格式 virtualenv –no-site-packages -p python版本（具体的python安装路径） 环境名称 &emsp;&emsp;例如 virtualenv –no-site-packages djenv7 2、进入环境激活环境 cd scripitsactivate &emsp;&emsp;退出命令 deactivate 3、查看当前虚拟环境下已经安装的包（在虚拟环境激活状态下） pip list 或者 pip freeze 二、安装Django1、命令行下进入虚拟环境scripts 安装Django1.11版本 pip install django==1.11 三、创建Django项目1、进入上面创建的虚拟环境中并激活环境（也可以在pycharm中创建，但推荐使用命令行创建）2、 创建项目 格式django-admin startproject 项目名 例如django-admin startproject day01 &emsp;&emsp;使用manage.py启动服务 格式python manage.py runserver 3、创建应用 格式python manage.py startapp 应用名 例如python manage.py startapp app 项目创完成后就可以启动Django内置服务器来访问当前创建的项目了 &emsp;&emsp;使用默认的启动ip和端口访问 127.0.0.1:8000 进入虚拟环境中（也可在pycharm中的terminal来进入虚拟环境，下面我是采用命令行的方式） cd scriptsactivatepython manage.py runserver &emsp;&emsp;可以通过访问django提供的后台管理界面 127.0.0.1:8000/admin 但是需要先创建超级管理员，创建管理员时需要在数据库中创建表，即制作迁移 注意： 由于python3不提供pymysqldb，所以需要先安装pymysql并引入mysqldb 四、安装pymysql1、 pip install pymysql2、在项目文件day01下的inin.py文件中引入pymysql并使用mysqldb()（python3中不在提供mysqldb） import pymysqlpymysql.install_as_MySQLdb() 五、制作迁移并创建管理员&emsp;1、制作项目迁移 格式： python manage.py migrate &emsp;2、创建超级管理员 python manage.py createsuperuser 输入用户名和邮箱、密码 六、创建一个简单的Django项目&emsp;1、先在app应用下views.py文件下创建一个相应处理函数12345# 导入一个响应from django.http import HttpResponsedef hello(request): return HttpResponse('hello world') 2、在项目文件夹下的init.py 文件中配置路由 url(正则， 视图函数) 1234# 导入应用下的viewsfrom app import views url(r'^hello/', views.hello), &emsp;3、 启动服务器并访问上面配置的url&emsp;4、 启动服务器 python manage.py runserver &emsp;5、 访问下面的url就会返回一个hell world 127.0.0.1:8000/hello/","tags":[{"name":"Django","slug":"Django","permalink":"http://yoursite.com/tags/Django/"}]}]