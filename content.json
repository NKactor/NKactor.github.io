[{"title":"cookie的使用","date":"2018-11-30T12:04:21.000Z","path":"2018/11/30/cookie的使用/","text":"cookie的使用–简单登录注册实现 一、登录&emsp;1.1 HTTP是无状态协议，无法保存用户的登录状态可以用cookie 存储用户的信息 – 但是这种方式并不安全所以后面采用 cookie + session 解决这种不安全，同时可以保持用户登录状态 登录时需要向cookie中设置一个随机字符串（token）令牌 token令牌: 是在用户登录成功后服务器返回的一个标识符，但是令牌有有效时间限制 &emsp;1.2 如何向cookie中存数据（令牌）&emsp;&emsp;在Django中可以从用户的请求中获取cookie值，下面采用登录注册为实例说明cookie的应用 当用户发出登录请求时，服务器获取请求，如果登录成功服务器会向用户返回一个响应，并将登录的令牌一同返回回去 #获取响应 res = HttpResponse() # 设置cookie res.set_cookie(&apos;token&apos;, value，有效时间（秒）) 如： res.set_cookie(&apos;token&apos;, &apos;123123&apos;，600) 参数解释： 绑定参数到cookie中 key表示设置的名称 value表示设置的值 max_age表示多少秒后过期 expires表示datetime类型的日期， 表示多久过期 &emsp; 1.3 如何做令牌校验&emsp;&emsp;做令牌校验需要先获取cookie值 &emsp;&emsp;在了解如何会获取cookie值前我们需要先了解request请求中的内容主要有哪些 字段 说明 COOKIE 传递客户端中的cookie内容 GET 获取HTTP GET请求中传递的参数。如：127.0.0.1/xxx/id=1 POST 获取HTTP POST请求中传递的参数 FILES 获取请求页面中的文件 path 获取当前请求的url路径 method 获取请求方式 &emsp;&emsp;获取cookie值： 由于请求中的cookie值是以字典的形式传给服务器，服务器可以通过字典取值的方式获取值，但推荐用get方式获取（但键不存在时不会报错） # GET 请求获取 token = request.GET.get(&apos;token&apos;) # POST 请求获取 token = request.POST.get(&apos;token&apos;) &emsp;&emsp;要做保持用户登录状态，则需要保存用户的cookie值，由于用户和cookie值之间是一对一的关系，可以考虑建一张token表用于保存用户cookie值,并做一对一关联 123class TokenUser(models.Model): token = models.CharField(max_length=30) user = models.OneToOneField(MyUser) &emsp;&emsp;但是由于每个用户登录后都会获取不同的cookie值，我们可以运用随机函数（random）产生，在开发中像这样的功能函数我们可以创建一个文件夹来保存这些工具（函数）。 在项目文件夹下创建一个名为utils的文件夹，我们把一些共用的函数放在这个文件夹下，同时还需要创建一个__init__.py文件（目的是告诉解释器把这个文件看成一个python包） &emsp;1.4 令牌校验成功与否后的操作&emsp;&emsp;假设登录后才能访问首页，要判断用户是否登录则需要在cookie有效时间内判断用户的请求是否有有效的cookie值，该cookie可以在数据中读取。 123456789def my_index(request): # 当访问127.0.0.1/my_index/ 时如果用户登录过，并且cookie有效，则跳转到index.html页面，否则返回登录页面 if request.method == 'GET': token = request.COOKIES.get('token') user_token = TokenUser.objects.filter(token=token) if user_token: return render(request, 'index.html') else: return HttpResponseRedirect('/login/') 注意： 当用render()返回页面时，浏览器的url不会改变成相应的url，所有这里需要用跳转 如： return render(request, &apos;index.html&apos;) return HttpResponseRedirect(&apos;/login/&apos;) 二、简单用户注册和登录用户注册：通过前端form表单向服务器提交用户注册信息，服务器通过request请求获取对应的信息，并在后端进行用户信息校验，并做出不同的响应。 用户登录：用户通过前端form表单向服务器提交登录信息，服务器通过request请求获取对应的登录信息，并在后端做用户登录信息校验，做出不同的响应，并返回用户此次登录的cookie值，用于保存用户登录状态。 &emsp;&emsp;用户注册：12345678910111213141516171819202122232425262728293031def register(request): if request.method == 'GET': # GET 访问 127.0.0.1/redister/ return render(request, 'register.html') if request.method == 'POST': username = request.POST.get('username') password = request.POST.get('password') password2 = request.POST.get('password2') # 判断用户名是否注册 re = MyUser.objects.filter(username=username).first() if re: err_name = '该用户已经被注册！' return render(request, 'register.html', &#123;'err_name': err_name&#125;) # 判断密码和确认密码是否相同 if password and password2: if password != password2: err_pwd = '两次密码输入不一致！' return render(request, 'register.html', &#123;'err_name': err_pwd&#125;) else: # 如果用户名存在，且密码和确认密码相同，则注册保存 MyUser.objects.create(username=username, password=password) # return render(request, 'login.html') # 跳转指定的地址页面 return HttpResponseRedirect('/login/') else: err_pwd = '密码不能为空！' return render(request, 'register.html', &#123;'err_name': err_pwd&#125;) &emsp;&emsp;用户登录：12345678910111213141516171819202122232425262728def login(request): if request.method == 'GET': return render(request, 'login.html') if request.method == 'POST': # 获取用户账号密码信息 username = request.POST.get('username') password = request.POST.get('password') # 验证是否输入账号密码 if not (username and password): return render(request, 'login.html', &#123;'err_name': '用户名或密码不能为空！'&#125;) # 判断是否有该用户的信息 user = MyUser.objects.filter(username=username, password=password).first() if not user: return render(request, 'login.html', &#123;'err_name': '该用户未注册！'&#125;) # 登录验证并给他一个令牌 res = HttpResponseRedirect('/my_index/') token = get_cookie_token() res.set_cookie('token', token, 600) token_user = TokenUser.objects.filter(user=user).first() if token_user: token_user.token = token else: TokenUser.objects.create(user=user, token=token) return res","tags":[{"name":"Django","slug":"Django","permalink":"http://yoursite.com/tags/Django/"}]},{"title":"模板基础","date":"2018-11-29T11:29:15.000Z","path":"2018/11/29/模板基础/","text":"模板基础用法、使用模板时的一些注意事项 一、模板基础&emsp;&emsp;1.1 在项目文件夹下创建一个templates文件夹&emsp;&emsp;1.2 在项目文件夹下的setting.py文件中TEMPLATES中添加&apos;DIRS&apos;: [os.path.join(BASE_DIR, &apos;templates&apos;)] &emsp;&emsp;如下：123456TEMPLATES = [ &#123; # 此处省略部分代码 'DIRS': [os.path.join(BASE_DIR, 'templates')] # 此处省略部分代码&#125; &emsp;&emsp;作用：‘DIRS’: [os.path.join(BASE_DIR, ‘templates’)] 这是告诉Django在当前项目路径下去找templates模板 二、模板使用&emsp;&emsp;2.1 创建模板在上面创建的文件夹下创建模板文件（html文件）用于渲染内容 在此之前需要先配置url和定义对应的视图函数 在项目文件夹下urls.py中添加 url(r&apos;^index&apos;, views.index) 并定义相应的index视图函数 &emsp;&emsp;如：123def index(request): stus = Student.objects.all() return render(request, 'index.html', &#123;'students': stus&#125;) render() 用于指定渲染页面的模板是哪个 模板中大部分都是html标签，最主要就是当模板拿到视图函数传入的数据时该如何解析 &emsp;&emsp;2.2 模板解析解析变量： {{ 变量 }} 解析标签： {% 标签 %} 标签有 for/if 等 {% for %} {% endfor %}/{% if %} {% endif %} endfor/endif 必须写 &emsp;&emsp;2.3 模板中的注释123456&lt;!-- 注释1 --&gt; 原生html注释会被浏览器解释，当查看源码时会显示 &#123;# 注释2 #&#125; 不会被浏览器解释并且不会在源码中显示&#123;% comment %&#125; 多行注释不会被浏览器解释并且不会在源码中显示 &lt;p&gt;注释3&lt;/p&gt; &lt;a&gt;注释4&lt;/a&gt;&#123;% endcomment %&#125; &emsp;&emsp;2.4 模板循环变量 模板变量 说明 forloop.counter 从1开始计数 forloop.counter0 从0开始计数 forloop.revcounter 倒序1结束 forloop.revcounter0 倒序0结束 forloop.first 第一个是true其他都为false forloop.last 最后一个是true其他都为false &emsp;在开发中模板界面不止一个，并且可能会有大量重复代码，我们可以考虑用模板继承，减少重复代码 &emsp;&emsp;2.5 基础模板&emsp;定义一个母版(base.html) 在母版中通过 进行占位，当子页面继承该母版时只需用相应的内容填充该位置即可,这种方式也称为挖坑 &emsp;具体如下： 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt; &#123;% block title %&#125; &#123;% endblock %&#125; &lt;/title&gt; &#123;% block css %&#125; &#123;% endblock %&#125; &#123;% block js %&#125; &#123;% endblock %&#125;&lt;/head&gt;&lt;body&gt; &#123;% block content %&#125; &#123;% endblock %&#125;&lt;/body&gt;&lt;/html&gt; &emsp;&emsp;在母版中可以添加相应的内容，但是一般不这么做因为母版只负责占位(挖坑)，如果有些内容在很多页面都要用到，可以在定义一个模板，让其继承母版，再把需要用的内容添加在该模板中，让其他渲染模板继承这个模板。&emsp;&emsp;注意： 如果渲染模板继承上面的模板，可以保留父模板的内容，也可以重新填充。 保留父模板内容： ，同时也可以写自己的内容 &emsp;&emsp;比如jQuery是公共的js文件，但是有些页面也有自己的js，此时就可以把jQuery放在母版的第一个孩子（模板）中，通过保留，然后在写自己的js, 但是注意不用super直接写会把父模板的内容覆盖。","tags":[{"name":"Django","slug":"Django","permalink":"http://yoursite.com/tags/Django/"}]},{"title":"模型关系之一对多","date":"2018-11-29T11:25:19.000Z","path":"2018/11/29/模型关系之一对多/","text":"模型关系之一对多 一、一对多关系中的反正向查询&emsp;&emsp;1.1 定义学生和班级模型123456789101112131415class Grade(models.Model): gname = models.CharField(max_length=20) create_time = models.DateField(auto_now_add=True) class Meta: db_table = 'tb_grade'class Student(models.Model): name = models.CharField(max_length=10, unique=True) # 定义外键(一对多关系中外键在多的一边) grade = models.ForeignKey(Grade, null=True) class Meta: # 指定Student模型映射到数据库中时，对应的表名。 db_table = 'tb_student' &emsp;&emsp;1.2 对学生和班级进行反正向查询12345678910111213141516# 正向查询def sel_grade_by_stu(request): \"\"\"通过学生查对应的班级\"\"\" stu = Student.objects.filter(name='大明').first() stu_grade = stu.grade gname = stu_grade.gname return HttpResponse(f'&#123;stu.name&#125;\\t&#123;gname&#125;')# 反向查询def sel_stu_by_grade(request): \"\"\"通过班级查询班级所有学生\"\"\" grade = Grade.objects.filter(id=15).first() stus = grade.student_set.all() names = [stu.name for stu in stus] return HttpResponse(f'&#123;names&#125;') 一对多关联查询时，当多的查一的需要用 对象.模型名小写 如：stu.grade 当一的查多的需要用 对象.模型名_set（返回的是关联关系） 如： grade.student_set.all() 查看所有的查询集 二、多对多关联查询&emsp;&emsp;2.1 在上面的基础上再创建一个课程模型（学生和课程就是多对多关系）1234567class Course(models.Model): cname = models.CharField(max_length=10) # 定义多对多关联 stu = models.ManyToManyField(Student) class Meta: db_table = 'tb_course' 注意：ManyToManyField 字段定义在需要关联的任何一个模型中都可以，迁移时会产生一张第三张表,用于维持多对多关系 此时多对多关系就可以看成第三表和另外两张表的两个一对多关系 &emsp;&emsp;2.2 多对多关联查询通过学生查询学生课程，并添加课程 stu = Student.objects.filter(name=&apos;大明&apos;).first() cou = Course.objects.filter(cname=&apos;高数&apos;).first() # 添加课程 add(对象) # stu.course_set.add(cou) # 移除课程 remove(对象) stu.course_set.remove(cou) 多对多关联查询与一对多关系中的反正向查询类似，主要注意set的使用情况","tags":[{"name":"Django","slug":"Django","permalink":"http://yoursite.com/tags/Django/"}]},{"title":"ORM查询数据操作","date":"2018-11-28T03:43:48.000Z","path":"2018/11/28/ORM查询数据操作/","text":"ORM查询数据操作 一、ORM查询数据库1.1 filter()过滤器 – 精确查询&emsp;作用： 返回符合条件的数据 对象.objects.filter(筛选条件): 查询满足条件的查询集 1.2 获取所有数据 对象.objects.all() : 返回数据库中所有数据集 1.3 获取满足条件的数据 对象.objects.get(筛选条件)： &emsp;注意：获取满足条件的对象，但是查询条件必须存在，并且查询数据条数为1条，否则都会报错而filter()当查询条件不存在时返回空查询集，数据条数大于1时，返回一个列表类型的查询集 对象.objects.exclude(过滤条件)返回不满足条件的结果集（QuerySet），也可以说是过滤掉满足条件的结果集 1.4 组合条件查询&emsp;&emsp;如：1234# 查询年龄等于18且性别为女的学生信息stus = Student.objects.filter(age=18).filter(gender=0)# 多个条件可以写在一个filter中（推荐使用）stus = Student.objects.filter(age=18, gender=0) 二、 从查询集中获取数据&emsp;2.1 下标获取 stus = Student.objects.all()如： stus[0]但是注意下标越界异常 &emsp;2.2 first() 获取第一个元素 如： stus.first() &emsp;2.3 last() 获取最后一个元素 如： stus.last() 三、 排序 order_by 对象.objects.order_by(排序字段) &emsp;&emsp;如： 1234stus = Student.objects.all().order_by('-id') # 排序 order_by # 降序 -id 在sql中 id desc # 升序 id 在sql中 id asc &emsp;&emsp;测试可以通过values()获取对象键值对 如：stus.values() 限制查询集，可以使用下标的方法进行限制，等同于sql中的limit模型名.objects.all()[0:5] 小标不能为负数 函数 说明 first() 返回查询集中的第一个对象 last() 返回查询集中的最后一个对象 count() 返回当前查询集中的对象个数 exists() 判断查询集中是否有数据，如果有数据返回True，没有返回False 四、 模糊查询&emsp; 4.1 contains 包含 类似于 like %小% 如： stus = Student.objects.filter(name__contains=’小’) &emsp; 4.2 endswith 以什么结束 类似于 like %小 如： stus = Student.objects.filter(name_endswith=’明’) &emsp; 4.3 startswith 以什么开头 类似于 like 大% 如： stus = Student.objects.filter(name__startswith=’大’) &emsp;&emsp;注意：以上模糊查询中都对大小写敏感，可以在前面加 i（ignore）忽略大小写（icontains、istartwith、iendswith） &emsp; 4.4 集合运算 – in 如：stus = Student.objects.filter(id__in=[2, 3, 5, 14])stus = Student.objects.filter(pk__in=[2, 3, 5, 14]) &emsp; 4.5 比较运算 gt（大于）、gte（大于等于）、lt（小于）、lte（小于等于） 如：stus = Student.objects.filter(age__gt=18) &emsp; 4.5 聚合 aggreagate()sql中有的聚合函数这里都有（Sum Avg Max Min Count） 需要导入相应的包 from django.db.models import Sum, Avg, Max, Min, Count &emsp;&emsp;如： avg_age = Student.objects.all().aggregate(Avg(‘age’))sum_age = Student.objects.all().aggregate(Sum(‘age’)) &emsp; 4.6 逻辑运算（且（&amp;）、 或（|）、 非（~））逻辑运算需要借助F对象和Q对象，所以需要先导入相应的包 from django.db.models import F, Q &emsp;&emsp;如：1234567891011121314# 查询age=18或者gender=0的学生信息# Q(条件)stus = Student.objects.filter(Q(age=18), Q(gender=0)) # 相当于与（&amp;）stus = Student.objects.filter(Q(age=18) &amp; Q(gender=0))stus = Student.objects.filter(Q(age=18) | Q(gender=0))stus = Student.objects.filter(~Q(age=18) &amp; Q(gender=1))# F() 对象# 查询语文成绩比数学成绩大的学生信息stus = Student.objects.filter(yuwen__gt=F('shuxue'))# 查询语文成绩比数学成绩大10分的学生信息stus = Student.objects.filter(yuwen__gt=F('shuxue') + 10)# F对象支持数学运算 小结 条件 说明 exact、iexact 精确匹配、忽略大小写的精确匹配查询 contains、icontains、startswith、istartswith、endswith、iendswith 基于like的模糊查询 in 集合运算 gt、gte、lt、lte 大于、大于等于、小于、 小于等于关系运算 range 指定范围查询（SQL中的between…and…） year、month、day、week_day、hour、minute、second 查询时间日期 isnull 查询空值（True）或非空值（False） search 基于全文索引的全文检索 regex、iregex 基于正则表达式的模糊匹配查询 六、一对一（OneToOneField）的关联查询&emsp; 6.1 概述： 在python中一对一的关系主要通过OneToOneField来实现，与sql中的外键关联差不多，但是在一对一的关系中外键可以添加在需要关联的任意一个模型中（一对多关系中外键一般加在多的一边） &emsp;例如：123456789101112131415161718# 学生类class Student(models.Model): name = models.CharField(max_length=20) age = models.IntegerField(default=18) class Meta: # 设置表明 db_table = 'tb_student'# 学生信息扩展类class StuInfo(models.Model): phone = models.CharField(max_length=11) address = models.CharField(max_length=31) # 添加外键 stu = models.OneToOneField(Student) class Meta: db_table = 'tb_stuinfo' &emsp;&emsp;注意：OneToOneField等价ForeignKey,且约束unique=True,并且外键映射到数据库中时会键外键字段名默认为 —- 字段_id 如上面定义的stu外键在数据库中为： stu_id ####&emsp; 6.2 正向关联查询 子表查询主表为 — 正向查询 主表查询子表为 — 反向查询&emsp;&emsp;如：12345# 正向查询# 查询电话为10011的学生姓名（子表查主表）stu_info = StuInfo.objects.filter(phone='10011').first()stu = stu_info.stuname = stu.name ####&emsp; 6.2 反向关联查询&emsp;&emsp;如：12345# 反向查询 # 查询名字为小明的学生电话name='小明' stu = Student.objects.filter(name='小明').first() stu_info = stu.stuinfo phone = stu_info.phone","tags":[{"name":"Django","slug":"Django","permalink":"http://yoursite.com/tags/Django/"}]},{"title":"认识Django模型","date":"2018-11-27T12:54:38.000Z","path":"2018/11/27/认识Django模型/","text":"Django简单模型认识和创建模型、生成迁移文件、制作迁移 一、模型介绍&emsp;1. 创建一个简单的学生模型1234567891011121314class Student(models.Model): # 继承models.Model # 定义数据字段 name = models.CharField(max_length=10, unique=True) age = models.IntegerField(default=18) gender = models.BooleanField(default=1) # 创建数据时间，默认为当前时间： auto_now_add=True create_time = models.DateTimeField(auto_now_add=True, null=True) # auto_now : 修改时间， 每次修改学生信息时，修改该字段的时间为当前时间 operate_time = models.DateTimeField(auto_now=True, null=True) class Meta: # 指定Student模型映射到数据库中时，对应的表名。 db_table = 'tb_student' 2. 配置数据库 2.1 在项目文件夹下的setting.py中修改数据库类型和配置数据库连接信息 &emsp;&emsp;如：12345678910DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'NAME': 'dj7', 'USER': 'root', 'PASSWORD': '123456', 'HOST': 'localhost', 'PORT': 3306 &#125;&#125; 2.2 其次需要在项目文件夹下的init.py中添加对应的数据库驱动 mysql如下： import pymysql (如果没有pymysql的需要安装pymysql第三方库)pymysql.install_as_MySQLdb() &emsp;3. 注册应用 在项目文件下的setting.py文件中的INSTALLED_APPS最后添加应用名 &emsp;&emsp;如：1234INSTALLED_APPS = [ 这里省略部分默认代码 'app'] &emsp;4. 生成迁移文件 格式： python manage.py makemigrations 此时会在项目文件夹下的migration文件夹下创建一个迁移文件 如：0001_initial.py &emsp;5. 制作迁移 格式： python manage.py migrate 此时在数据库中就会创建一张与模型向对应的数据库表（其中自动创建一个id字段并且自动增长和是主键） 二、更改启动服务的ip和端口 格式：python manage.py runserver ip:port或者格式：python manage.py runserver port &emsp;注意：后面参数可以是IP：port 或者 port，不能只是ip 三、Debug(程序调试) 在自己认为可能出现错误的地方添加断点，再通过Debug对程序进行检查调试 python中可以通过debug控制台打印程序运行值检查是否出错 四、通过ORM操作数据库(CRUD操作)&emsp;在上面创建的模型基础上通过模型去更改操作数据库表 &emsp;1. 配置url解析12345678910111213# 需要先导入app应用下的views(视图)from app import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), # 新增数据 # 配置url，并调用相应的视图函数 url(r'add_stu/', views.add_stu), # 删除数据 url(r'del_stu/', views.del_stu), # 修改数据 url(r'^up_stu', views.up_stu),] &emsp;2. 在应用(app)文件夹下views.py文件中定义与url相对应的视图函数12345678910111213141516171819202122232425262728293031323334353637383940414243# 引入Student模型from app.models import Studentdef add_stu(request): # 创建向数据库student表中插入数据的函数 # 添加数据 # 方式一： # stu = Student() # stu.name = '小明' # 向数据库中插入数据 # stu.save() # 方式二： Student.objects.create(name='大锤11', age=19) # 返回响应 return HttpResponse('添加成功！')def del_stu(request): # 实现删除数据操作 # 1. 先查询name=‘大锤’的信息 Student.objects.filter(name='大锤11').delete() return HttpResponse('删除成功！')def up_stu(request): # 修改student表中的数据 # 方式一： # stus = Student.objects.filter(name='小明') # 获取小明对象 # stu = stus[0] # stu.name = '大锤' # stu.save() # 方式二： # stu = Student.objects.filter(name='小明').first() # stu.name = '大锤' # stu.save() # 方式三： Student.objects.filter(name='小明').update(name='小明') return HttpResponse('修改成功！') 五、模型中定义的数据类型和数据库（mysql）中的数据类型的关系&emsp;5.1 定义模型 &emsp;&emsp; 1. 字段要求 字段名不能使python的保留字，否则会导致语法错误字段名不能有多个连续下划线，否则会影响ORM查询操作 &emsp;5.2 模型中的数据类型模型字段类型 字段类 说明 AutoField 自增ID字段 BigIntegerField 64位有符号整数 BinaryField 存储二进制数据的字段，对应Python的bytes类型 BooleanField 存储True或False CharField 长度较小的字符串 DateField 存储日期，有auto_now和auto_now_add属性 DateTimeField 存储日期和日期，两个附加属性同上 DecimalField 存储固定精度小数，有max_digits（有效位数）和decimal_places（小数点后面）两个必要的参数 DurationField 存储时间跨度 EmailField 与CharField相同，可以用EmailValidator验证 FileField 文件上传字段 FloatField 存储浮点数 ImageField 其他同FileFiled，要验证上传的是不是有效图像 IntegerField 存储32位有符号整数。 GenericIPAddressField 存储IPv4或IPv6地址 NullBooleanField 存储True、False或null值 PositiveIntegerField 存储无符号整数（只能存储正数） SlugField 存储slug（简短标注） SmallIntegerField 存储16位有符号整数 TextField 存储数据量较大的文本 TimeField 存储时间 URLField 存储URL的CharField UUIDField 存储全局唯一标识符 &emsp;常用的类型主要有以下几类（自己总结的） 类型 说明 自增id字段 AutoField 数字类型 IntegerField、FloatField、DecimalField 字符串类型 CharField、TextField 时间类型 DateField、DateTimeField、TimeField 文件类型 FielField、ImageField 布尔和空 BooleanField、NullBoolField 模型字段属性 选项 说明 null 数据库中对应的字段是否允许为NULL，默认为False blank 后台模型管理验证数据时，是否允许为NULL，默认为False choices 设定字段的选项，各元组中的第一个值是设置在模型上的值，第二值是人类可读的值 db_column 字段对应到数据库表中的列名，未指定时直接使用字段的名称 db_index 设置为True时将在该字段创建索引 db_tablespace 为有索引的字段设置使用的表空间，默认为DEFAULT_INDEX_TABLESPACE default 字段的默认值 editable 字段在后台模型管理或ModelForm中是否显示，默认为True error_messages 设定字段抛出异常时的默认消息的字典，其中的键包括null、blank、invalid、invalid_choice、unique和unique_for_date help_text 表单小组件旁边显示的额外的帮助文本。 primary_key 将字段指定为模型的主键，未指定时会自动添加AutoField用于主键，只读。 unique 设置为True时，表中字段的值必须是唯一的 verbose_name 字段在后台模型管理显示的名称，未指定时使用字段的名称 模型元数据选项选项 | 说明:-:|:-abstract | 设置为True时模型是抽象父类app_label | 如果定义模型的应用不在INSTALLED_APPS中可以用该属性指定db_table | 模型使用的数据表名称db_tablespace | 模型使用的数据表空间default_related_name | 关联对象回指这个模型时默认使用的名称，默认为&lt;model_name&gt;_setget_latest_by | 模型中可排序字段的名称。managed | 设置为True时，Django在迁移中创建数据表并在执行flush管理命令时把表移除order_with_respect_to | 标记对象为可排序的ordering | 对象的默认排序permissions | 创建对象时写入权限表的额外权限default_permissions | 默认为(‘add’, ‘change’, ‘delete’)unique_together | 设定组合在一起时必须独一无二的字段名index_together | 设定一起建立索引的多个字段名verbose_name | 为对象设定人类可读的名称verbose_name_plural | 设定对象的复数名称","tags":[{"name":"Django","slug":"Django","permalink":"http://yoursite.com/tags/Django/"}]},{"title":"初始Django","date":"2018-11-27T10:30:03.000Z","path":"2018/11/27/初始Django/","text":"初识Django和使用Django创建一个简单的web应用 一、命令行安装虚拟环境1. 安装虚拟环境 格式： pip install virtualenv 2.virtualenv 参数解释 -p参数： 指定安装的python版本–no-site-packages参数： 指定安装虚拟环境的空文件夹 二、创建虚拟环境1、命令格式 virtualenv –no-site-packages -p python版本（具体的python安装路径） 环境名称 &emsp;&emsp;例如 virtualenv –no-site-packages djenv7 2、进入环境激活环境 cd scripitsactivate &emsp;&emsp;退出命令 deactivate 3、查看当前虚拟环境下已经安装的包（在虚拟环境激活状态下） pip list 或者 pip freeze 二、安装Django1、命令行下进入虚拟环境scripts 安装Django1.11版本 pip install django==1.11 三、创建Django项目1、进入上面创建的虚拟环境中并激活环境（也可以在pycharm中创建，但推荐使用命令行创建）2、 创建项目 格式django-admin startproject 项目名 例如django-admin startproject day01 &emsp;&emsp;使用manage.py启动服务 格式python manage.py runserver 3、创建应用 格式python manage.py startapp 应用名 例如python manage.py startapp app 项目创完成后就可以启动Django内置服务器来访问当前创建的项目了 &emsp;&emsp;使用默认的启动ip和端口访问 127.0.0.1:8000 进入虚拟环境中（也可在pycharm中的terminal来进入虚拟环境，下面我是采用命令行的方式） cd scriptsactivatepython manage.py runserver &emsp;&emsp;可以通过访问django提供的后台管理界面 127.0.0.1:8000/admin 但是需要先创建超级管理员，创建管理员时需要在数据库中创建表，即制作迁移 注意： 由于python3不提供pymysqldb，所以需要先安装pymysql并引入mysqldb 四、安装pymysql1、 pip install pymysql2、在项目文件day01下的inin.py文件中引入pymysql并使用mysqldb()（python3中不在提供mysqldb） import pymysqlpymysql.install_as_MySQLdb() 五、制作迁移并创建管理员&emsp;1、制作项目迁移 格式： python manage.py migrate &emsp;2、创建超级管理员 python manage.py createsuperuser 输入用户名和邮箱、密码 六、创建一个简单的Django项目&emsp;1、先在app应用下views.py文件下创建一个相应处理函数12345# 导入一个响应from django.http import HttpResponsedef hello(request): return HttpResponse('hello world') 2、在项目文件夹下的init.py 文件中配置路由 url(正则， 视图函数) 1234# 导入应用下的viewsfrom app import views url(r'^hello/', views.hello), &emsp;3、 启动服务器并访问上面配置的url&emsp;4、 启动服务器 python manage.py runserver &emsp;5、 访问下面的url就会返回一个hell world 127.0.0.1:8000/hello/","tags":[{"name":"Django","slug":"Django","permalink":"http://yoursite.com/tags/Django/"}]}]