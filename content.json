[{"title":"ORM查询数据操作","date":"2018-11-28T03:43:48.000Z","path":"2018/11/28/ORM查询数据操作/","text":"ORM查询数据操作 一、ORM查询数据库1.1 filter()过滤器 – 精确查询&emsp;作用： 返回符合条件的数据 对象.objects.filter(筛选条件): 查询满足条件的查询集 1.2 获取所有数据 对象.objects.all() : 返回数据库中所有数据集 1.3 获取满足条件的数据 对象.objects.get(筛选条件)： &emsp;注意：获取满足条件的对象，但是查询条件必须存在，并且查询数据条数为1条，否则都会报错而filter()当查询条件不存在时返回空查询集，数据条数大于1时，返回一个列表类型的查询集 对象.objects.exclude(过滤条件)返回不满足条件的结果集（QuerySet），也可以说是过滤掉满足条件的结果集 1.4 组合条件查询&emsp;&emsp;如：1234# 查询年龄等于18且性别为女的学生信息stus = Student.objects.filter(age=18).filter(gender=0)# 多个条件可以写在一个filter中（推荐使用）stus = Student.objects.filter(age=18, gender=0) 二、 从查询集中获取数据&emsp;2.1 下标获取 stus = Student.objects.all()如： stus[0]但是注意下标越界异常 &emsp;2.2 first() 获取第一个元素 如： stus.first() &emsp;2.3 last() 获取最后一个元素 如： stus.last() 三、 排序 order_by 对象.objects.order_by(排序字段) &emsp;&emsp;如： 1234stus = Student.objects.all().order_by('-id') # 排序 order_by # 降序 -id 在sql中 id desc # 升序 id 在sql中 id asc &emsp;&emsp;测试可以通过values()获取对象键值对 如：stus.values() 限制查询集，可以使用下标的方法进行限制，等同于sql中的limit模型名.objects.all()[0:5] 小标不能为负数 函数 说明 first() 返回查询集中的第一个对象 last() 返回查询集中的最后一个对象 count() 返回当前查询集中的对象个数 exists() 判断查询集中是否有数据，如果有数据返回True，没有返回False 四、 模糊查询&emsp; 4.1 contains 包含 类似于 like %小% 如： stus = Student.objects.filter(name__contains=’小’) &emsp; 4.2 endswith 以什么结束 类似于 like %小 如： stus = Student.objects.filter(name_endswith=’明’) &emsp; 4.3 startswith 以什么开头 类似于 like 大% 如： stus = Student.objects.filter(name__startswith=’大’) &emsp;&emsp;注意：以上模糊查询中都对大小写敏感，可以在前面加 i（ignore）忽略大小写（icontains、istartwith、iendswith） &emsp; 4.4 集合运算 – in 如：stus = Student.objects.filter(id__in=[2, 3, 5, 14])stus = Student.objects.filter(pk__in=[2, 3, 5, 14]) &emsp; 4.5 比较运算 gt（大于）、gte（大于等于）、lt（小于）、lte（小于等于） 如：stus = Student.objects.filter(age__gt=18) &emsp; 4.5 聚合 aggreagate()sql中有的聚合函数这里都有（Sum Avg Max Min Count） 需要导入相应的包 from django.db.models import Sum, Avg, Max, Min, Count &emsp;&emsp;如： avg_age = Student.objects.all().aggregate(Avg(‘age’))sum_age = Student.objects.all().aggregate(Sum(‘age’)) &emsp; 4.6 逻辑运算（且（&amp;）、 或（|）、 非（~））逻辑运算需要借助F对象和Q对象，所以需要先导入相应的包 from django.db.models import F, Q &emsp;&emsp;如：1234567891011121314# 查询age=18或者gender=0的学生信息# Q(条件)stus = Student.objects.filter(Q(age=18), Q(gender=0)) # 相当于与（&amp;）stus = Student.objects.filter(Q(age=18) &amp; Q(gender=0))stus = Student.objects.filter(Q(age=18) | Q(gender=0))stus = Student.objects.filter(~Q(age=18) &amp; Q(gender=1))# F() 对象# 查询语文成绩比数学成绩大的学生信息stus = Student.objects.filter(yuwen__gt=F('shuxue'))# 查询语文成绩比数学成绩大10分的学生信息stus = Student.objects.filter(yuwen__gt=F('shuxue') + 10)# F对象支持数学运算 小结条件 | 说明:-:|:-exact/iexact | 精确匹配/忽略大小写的精确匹配查询contains/icontains/startswith/istartswith/endswith/iendswith | 基于like的模糊查询in | 集合运算gt/gte/lt/lte | 大于/大于等于/小于/小于等于关系运算range | 指定范围查询（SQL中的between…and…）year/month/day/week_day/hour/minute/second | 查询时间日期isnull | 查询空值（True）或非空值（False）search | 基于全文索引的全文检索regex/iregex | 基于正则表达式的模糊匹配查询 六、一对一（OneToOneField）的关联查询&emsp; 6.1 概述： 在python中一对一的关系主要通过OneToOneField来实现，与sql中的外键关联差不多，但是在一对一的关系中外键可以添加在需要关联的任意一个模型中（一对多关系中外键一般加在多的一边） &emsp;例如：123456789101112131415161718# 学生类class Student(models.Model): name = models.CharField(max_length=20) age = models.IntegerField(default=18) class Meta: # 设置表明 db_table = 'tb_student'# 学生信息扩展类class StuInfo(models.Model): phone = models.CharField(max_length=11) address = models.CharField(max_length=31) # 添加外键 stu = models.OneToOneField(Student) class Meta: db_table = 'tb_stuinfo' &emsp;&emsp;注意：OneToOneField等价ForeignKey,且约束unique=True,并且外键映射到数据库中时会键外键字段名默认为 —- 字段_id 如上面定义的stu外键在数据库中为： stu_id ####&emsp; 6.2 正向关联查询 子表查询主表为 — 正向查询 主表查询子表为 — 反向查询&emsp;&emsp;如：12345# 正向查询# 查询电话为10011的学生姓名（子表查主表）stu_info = StuInfo.objects.filter(phone='10011').first()stu = stu_info.stuname = stu.name ####&emsp; 6.2 反向关联查询&emsp;&emsp;如：12345# 反向查询 # 查询名字为小明的学生电话name='小明' stu = Student.objects.filter(name='小明').first() stu_info = stu.stuinfo phone = stu_info.phone","tags":[{"name":"Django","slug":"Django","permalink":"http://yoursite.com/tags/Django/"}]},{"title":"认识Django模型","date":"2018-11-27T12:54:38.000Z","path":"2018/11/27/认识Django模型/","text":"Django简单模型认识和创建模型、生成迁移文件、制作迁移 一、模型介绍&emsp;1. 创建一个简单的学生模型1234567891011121314class Student(models.Model): # 继承models.Model # 定义数据字段 name = models.CharField(max_length=10, unique=True) age = models.IntegerField(default=18) gender = models.BooleanField(default=1) # 创建数据时间，默认为当前时间： auto_now_add=True create_time = models.DateTimeField(auto_now_add=True, null=True) # auto_now : 修改时间， 每次修改学生信息时，修改该字段的时间为当前时间 operate_time = models.DateTimeField(auto_now=True, null=True) class Meta: # 指定Student模型映射到数据库中时，对应的表名。 db_table = 'tb_student' 2. 配置数据库 2.1 在项目文件夹下的setting.py中修改数据库类型和配置数据库连接信息 &emsp;&emsp;如：12345678910DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'NAME': 'dj7', 'USER': 'root', 'PASSWORD': '123456', 'HOST': 'localhost', 'PORT': 3306 &#125;&#125; 2.2 其次需要在项目文件夹下的init.py中添加对应的数据库驱动 mysql如下： import pymysql (如果没有pymysql的需要安装pymysql第三方库)pymysql.install_as_MySQLdb() &emsp;3. 注册应用 在项目文件下的setting.py文件中的INSTALLED_APPS最后添加应用名 &emsp;&emsp;如：1234INSTALLED_APPS = [ 这里省略部分默认代码 'app'] &emsp;4. 生成迁移文件 格式： python manage.py makemigrations 此时会在项目文件夹下的migration文件夹下创建一个迁移文件 如：0001_initial.py &emsp;5. 制作迁移 格式： python manage.py migrate 此时在数据库中就会创建一张与模型向对应的数据库表（其中自动创建一个id字段并且自动增长和是主键） 二、更改启动服务的ip和端口 格式：python manage.py runserver ip:port或者格式：python manage.py runserver port &emsp;注意：后面参数可以是IP：port 或者 port，不能只是ip 三、Debug(程序调试) 在自己认为可能出现错误的地方添加断点，再通过Debug对程序进行检查调试 python中可以通过debug控制台打印程序运行值检查是否出错 四、通过ORM操作数据库(CRUD操作)&emsp;在上面创建的模型基础上通过模型去更改操作数据库表 &emsp;1. 配置url解析12345678910111213# 需要先导入app应用下的views(视图)from app import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), # 新增数据 # 配置url，并调用相应的视图函数 url(r'add_stu/', views.add_stu), # 删除数据 url(r'del_stu/', views.del_stu), # 修改数据 url(r'^up_stu', views.up_stu),] &emsp;2. 在应用(app)文件夹下views.py文件中定义与url相对应的视图函数12345678910111213141516171819202122232425262728293031323334353637383940414243# 引入Student模型from app.models import Studentdef add_stu(request): # 创建向数据库student表中插入数据的函数 # 添加数据 # 方式一： # stu = Student() # stu.name = '小明' # 向数据库中插入数据 # stu.save() # 方式二： Student.objects.create(name='大锤11', age=19) # 返回响应 return HttpResponse('添加成功！')def del_stu(request): # 实现删除数据操作 # 1. 先查询name=‘大锤’的信息 Student.objects.filter(name='大锤11').delete() return HttpResponse('删除成功！')def up_stu(request): # 修改student表中的数据 # 方式一： # stus = Student.objects.filter(name='小明') # 获取小明对象 # stu = stus[0] # stu.name = '大锤' # stu.save() # 方式二： # stu = Student.objects.filter(name='小明').first() # stu.name = '大锤' # stu.save() # 方式三： Student.objects.filter(name='小明').update(name='小明') return HttpResponse('修改成功！') 五、模型中定义的数据类型和数据库（mysql）中的数据类型的关系&emsp;5.1 定义模型 &emsp;&emsp; 1. 字段要求 字段名不能使python的保留字，否则会导致语法错误字段名不能有多个连续下划线，否则会影响ORM查询操作 &emsp;5.2 模型中的数据类型模型字段类型 字段类 说明 AutoField 自增ID字段 BigIntegerField 64位有符号整数 BinaryField 存储二进制数据的字段，对应Python的bytes类型 BooleanField 存储True或False CharField 长度较小的字符串 DateField 存储日期，有auto_now和auto_now_add属性 DateTimeField 存储日期和日期，两个附加属性同上 DecimalField 存储固定精度小数，有max_digits（有效位数）和decimal_places（小数点后面）两个必要的参数 DurationField 存储时间跨度 EmailField 与CharField相同，可以用EmailValidator验证 FileField 文件上传字段 FloatField 存储浮点数 ImageField 其他同FileFiled，要验证上传的是不是有效图像 IntegerField 存储32位有符号整数。 GenericIPAddressField 存储IPv4或IPv6地址 NullBooleanField 存储True、False或null值 PositiveIntegerField 存储无符号整数（只能存储正数） SlugField 存储slug（简短标注） SmallIntegerField 存储16位有符号整数 TextField 存储数据量较大的文本 TimeField 存储时间 URLField 存储URL的CharField UUIDField 存储全局唯一标识符 &emsp;常用的类型主要有以下几类（自己总结的） 类型 说明 自增id字段 AutoField 数字类型 IntegerField、FloatField、DecimalField 字符串类型 CharField、TextField 时间类型 DateField、DateTimeField、TimeField 文件类型 FielField、ImageField 布尔和空 BooleanField、NullBoolField 模型字段属性 选项 说明 null 数据库中对应的字段是否允许为NULL，默认为False blank 后台模型管理验证数据时，是否允许为NULL，默认为False choices 设定字段的选项，各元组中的第一个值是设置在模型上的值，第二值是人类可读的值 db_column 字段对应到数据库表中的列名，未指定时直接使用字段的名称 db_index 设置为True时将在该字段创建索引 db_tablespace 为有索引的字段设置使用的表空间，默认为DEFAULT_INDEX_TABLESPACE default 字段的默认值 editable 字段在后台模型管理或ModelForm中是否显示，默认为True error_messages 设定字段抛出异常时的默认消息的字典，其中的键包括null、blank、invalid、invalid_choice、unique和unique_for_date help_text 表单小组件旁边显示的额外的帮助文本。 primary_key 将字段指定为模型的主键，未指定时会自动添加AutoField用于主键，只读。 unique 设置为True时，表中字段的值必须是唯一的 verbose_name 字段在后台模型管理显示的名称，未指定时使用字段的名称 模型元数据选项选项 | 说明:-:|:-abstract | 设置为True时模型是抽象父类app_label | 如果定义模型的应用不在INSTALLED_APPS中可以用该属性指定db_table | 模型使用的数据表名称db_tablespace | 模型使用的数据表空间default_related_name | 关联对象回指这个模型时默认使用的名称，默认为&lt;model_name&gt;_setget_latest_by | 模型中可排序字段的名称。managed | 设置为True时，Django在迁移中创建数据表并在执行flush管理命令时把表移除order_with_respect_to | 标记对象为可排序的ordering | 对象的默认排序permissions | 创建对象时写入权限表的额外权限default_permissions | 默认为(‘add’, ‘change’, ‘delete’)unique_together | 设定组合在一起时必须独一无二的字段名index_together | 设定一起建立索引的多个字段名verbose_name | 为对象设定人类可读的名称verbose_name_plural | 设定对象的复数名称","tags":[{"name":"Django","slug":"Django","permalink":"http://yoursite.com/tags/Django/"}]},{"title":"初始Django","date":"2018-11-27T10:30:03.000Z","path":"2018/11/27/初始Django/","text":"初识Django和使用Django创建一个简单的web应用 一、命令行安装虚拟环境1. 安装虚拟环境 格式： pip install virtualenv 2.virtualenv 参数解释 -p参数： 指定安装的python版本–no-site-packages参数： 指定安装虚拟环境的空文件夹 二、创建虚拟环境1、命令格式 virtualenv –no-site-packages -p python版本（具体的python安装路径） 环境名称 &emsp;&emsp;例如 virtualenv –no-site-packages djenv7 2、进入环境激活环境 cd scripitsactivate &emsp;&emsp;退出命令 deactivate 3、查看当前虚拟环境下已经安装的包（在虚拟环境激活状态下） pip list 或者 pip freeze 二、安装Django1、命令行下进入虚拟环境scripts 安装Django1.11版本 pip install django==1.11 三、创建Django项目1、进入上面创建的虚拟环境中并激活环境（也可以在pycharm中创建，但推荐使用命令行创建）2、 创建项目 格式django-admin startproject 项目名 例如django-admin startproject day01 &emsp;&emsp;使用manage.py启动服务 格式python manage.py runserver 3、创建应用 格式python manage.py startapp 应用名 例如python manage.py startapp app 项目创完成后就可以启动Django内置服务器来访问当前创建的项目了 &emsp;&emsp;使用默认的启动ip和端口访问 127.0.0.1:8000 进入虚拟环境中（也可在pycharm中的terminal来进入虚拟环境，下面我是采用命令行的方式） cd scriptsactivatepython manage.py runserver &emsp;&emsp;可以通过访问django提供的后台管理界面 127.0.0.1:8000/admin 但是需要先创建超级管理员，创建管理员时需要在数据库中创建表，即制作迁移 注意： 由于python3不提供pymysqldb，所以需要先安装pymysql并引入mysqldb 四、安装pymysql1、 pip install pymysql2、在项目文件day01下的inin.py文件中引入pymysql并使用mysqldb()（python3中不在提供mysqldb） import pymysqlpymysql.install_as_MySQLdb() 五、制作迁移并创建管理员&emsp;1、制作项目迁移 格式： python manage.py migrate &emsp;2、创建超级管理员 python manage.py createsuperuser 输入用户名和邮箱、密码 六、创建一个简单的Django项目&emsp;1、先在app应用下views.py文件下创建一个相应处理函数12345# 导入一个响应from django.http import HttpResponsedef hello(request): return HttpResponse('hello world') 2、在项目文件夹下的init.py 文件中配置路由 url(正则， 视图函数) 1234# 导入应用下的viewsfrom app import views url(r'^hello/', views.hello), &emsp;3、 启动服务器并访问上面配置的url&emsp;4、 启动服务器 python manage.py runserver &emsp;5、 访问下面的url就会返回一个hell world 127.0.0.1:8000/hello/","tags":[{"name":"Django","slug":"Django","permalink":"http://yoursite.com/tags/Django/"}]}]